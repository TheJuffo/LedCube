   1               		.file	"command_line.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  13               		.data
  14               	.LC0:
  15 0000 2000      		.string	" "
  16               		.text
  17               	.global	parse
  19               	parse:
  20               	.LFB1:
  21               		.file 1 "command_line.c"
   1:command_line.c **** /*
   2:command_line.c ****  * command_line.h
   3:command_line.c ****  * Created by Johan Andersson
   4:command_line.c ****  * Functions for reading uart and then executing commands.
   5:command_line.c ****  */
   6:command_line.c **** 
   7:command_line.c **** #include <string.h>
   8:command_line.c **** #include "command_line.h"
   9:command_line.c **** #include "uart.h"
  10:command_line.c **** 
  11:command_line.c **** 
  12:command_line.c **** #define CMD_BUFFER_SIZE 64
  13:command_line.c **** #define NO_OF_COMMANDS 2
  14:command_line.c **** 
  15:command_line.c **** char data[CMD_BUFFER_SIZE];
  16:command_line.c **** uint8_t current_pos = 0;
  17:command_line.c **** 
  18:command_line.c **** 
  19:command_line.c **** const char *command_list [NO_OF_COMMANDS]  = {
  20:command_line.c ****     "setmode",
  21:command_line.c ****     "launcheffect"
  22:command_line.c **** };
  23:command_line.c **** 
  24:command_line.c **** 
  25:command_line.c **** void read_and_execute()
  26:command_line.c **** {
  27:command_line.c **** 	char tempChar;
  28:command_line.c ****     
  29:command_line.c **** 	while(HasChars())
  30:command_line.c **** 	{
  31:command_line.c ****         receive_char(&tempChar);
  32:command_line.c **** 		data[current_pos] = tempChar;
  33:command_line.c ****         
  34:command_line.c **** 		if(tempChar == '\r')
  35:command_line.c **** 		{
  36:command_line.c ****             parse();
  37:command_line.c **** 		}
  38:command_line.c ****         
  39:command_line.c ****         current_pos++;
  40:command_line.c **** 	}
  41:command_line.c **** }
  42:command_line.c **** 
  43:command_line.c **** void parse()
  44:command_line.c **** {
  22               		.loc 1 44 0
  23               		.cfi_startproc
  24               	/* prologue: function */
  25               	/* frame size = 0 */
  26               	/* stack size = 0 */
  27               	.L__stack_usage = 0
  45:command_line.c ****     char * command;
  46:command_line.c ****     int i;
  47:command_line.c ****     
  48:command_line.c ****     command = strtok(data, " ");
  28               		.loc 1 48 0
  29 0000 80E0      		ldi r24,lo8(data)
  30 0002 90E0      		ldi r25,hi8(data)
  31 0004 60E0      		ldi r22,lo8(.LC0)
  32 0006 70E0      		ldi r23,hi8(.LC0)
  33 0008 0E94 0000 		call strtok
  34               	.LVL0:
  35               	/* epilogue start */
  49:command_line.c ****     
  50:command_line.c ****     for(i = 0; i < NO_OF_COMMANDS; i++)
  51:command_line.c ****     {
  52:command_line.c ****         if(strcasecmp(command, command_list[i]) == 0)
  53:command_line.c ****         {
  54:command_line.c ****             
  55:command_line.c ****         }
  56:command_line.c ****     }
  57:command_line.c ****     
  58:command_line.c ****     
  59:command_line.c **** }...
  36               		.loc 1 59 0
  37 000c 0895      		ret
  38               		.cfi_endproc
  39               	.LFE1:
  41               	.global	read_and_execute
  43               	read_and_execute:
  44               	.LFB0:
  26:command_line.c **** {
  45               		.loc 1 26 0
  46               		.cfi_startproc
  47 000e CF93      		push r28
  48               	.LCFI0:
  49               		.cfi_def_cfa_offset 3
  50               		.cfi_offset 28, -2
  51 0010 DF93      		push r29
  52               	.LCFI1:
  53               		.cfi_def_cfa_offset 4
  54               		.cfi_offset 29, -3
  55 0012 0F92      		push __tmp_reg__
  56               	.LCFI2:
  57               		.cfi_def_cfa_offset 5
  58 0014 CDB7      		in r28,__SP_L__
  59 0016 DEB7      		in r29,__SP_H__
  60               	.LCFI3:
  61               		.cfi_def_cfa_register 28
  62               	/* prologue: function */
  63               	/* frame size = 1 */
  64               	/* stack size = 3 */
  65               	.L__stack_usage = 3
  29:command_line.c **** 	while(HasChars())
  66               		.loc 1 29 0
  67 0018 00C0      		rjmp .L3
  68               	.LVL1:
  69               	.L5:
  31:command_line.c ****         receive_char(&tempChar);
  70               		.loc 1 31 0
  71 001a CE01      		movw r24,r28
  72 001c 0196      		adiw r24,1
  73 001e 0E94 0000 		call receive_char
  32:command_line.c **** 		data[current_pos] = tempChar;
  74               		.loc 1 32 0
  75 0022 8981      		ldd r24,Y+1
  76 0024 E091 0000 		lds r30,current_pos
  77 0028 F0E0      		ldi r31,lo8(0)
  78 002a E050      		subi r30,lo8(-(data))
  79 002c F040      		sbci r31,hi8(-(data))
  80 002e 8083      		st Z,r24
  34:command_line.c **** 		if(tempChar == '\r')
  81               		.loc 1 34 0
  82 0030 8D30      		cpi r24,lo8(13)
  83 0032 01F4      		brne .L4
  36:command_line.c ****             parse();
  84               		.loc 1 36 0
  85 0034 0E94 0000 		call parse
  86               	.L4:
  39:command_line.c ****         current_pos++;
  87               		.loc 1 39 0
  88 0038 8091 0000 		lds r24,current_pos
  89 003c 8F5F      		subi r24,lo8(-(1))
  90 003e 8093 0000 		sts current_pos,r24
  91               	.L3:
  29:command_line.c **** 	while(HasChars())
  92               		.loc 1 29 0 discriminator 1
  93 0042 0E94 0000 		call HasChars
  94 0046 8823      		tst r24
  95 0048 01F4      		brne .L5
  96               	/* epilogue start */
  41:command_line.c **** }
  97               		.loc 1 41 0
  98 004a 0F90      		pop __tmp_reg__
  99 004c DF91      		pop r29
 100 004e CF91      		pop r28
 101 0050 0895      		ret
 102               		.cfi_endproc
 103               	.LFE0:
 105               	.global	command_list
 106               		.data
 107               	.LC1:
 108 0002 7365 746D 		.string	"setmode"
 108      6F64 6500 
 109               	.LC2:
 110 000a 6C61 756E 		.string	"launcheffect"
 110      6368 6566 
 110      6665 6374 
 110      00
 113               	command_list:
 114 0017 0000      		.word	.LC1
 115 0019 0000      		.word	.LC2
 116               	.global	current_pos
 117               	.global	current_pos
 118               		.section .bss
 121               	current_pos:
 122 0000 00        		.skip 1,0
 123               		.comm data,64,1
 124               		.text
 125               	.Letext0:
 126               		.file 2 "/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:00000000 command_line.c
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccAGK4yQ.s:2      *ABS*:0000003f __SREG__
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccAGK4yQ.s:3      *ABS*:0000003e __SP_H__
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccAGK4yQ.s:4      *ABS*:0000003d __SP_L__
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccAGK4yQ.s:5      *ABS*:00000034 __CCP__
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccAGK4yQ.s:6      *ABS*:00000000 __tmp_reg__
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccAGK4yQ.s:7      *ABS*:00000001 __zero_reg__
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccAGK4yQ.s:19     .text:00000000 parse
                            *COM*:00000040 data
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccAGK4yQ.s:43     .text:0000000e read_and_execute
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccAGK4yQ.s:121    .bss:00000000 current_pos
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccAGK4yQ.s:113    .data:00000017 command_list

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
strtok
receive_char
HasChars
