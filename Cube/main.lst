   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  13               	.global	__vector_4
  15               	__vector_4:
  16               	.LFB2:
  17               		.file 1 "main.c"
   1:main.c        **** /*
   2:main.c        ****  * Code to controll an 8x8x8 ledcube using avr
   3:main.c        ****  * http://www.instructables.com/id/Led-Cube-8x8x8/
   4:main.c        ****  * See lisence.txt for lisence.
   5:main.c        ****  */
   6:main.c        **** #include "main.h"
   7:main.c        **** #include "effect.h"
   8:main.c        **** #include "launch_effect.h"
   9:main.c        **** #include "draw.h"
  10:main.c        **** #include "debug.h"
  11:main.c        **** #include "util.h"
  12:main.c        **** #include "uart.h"
  13:main.c        **** //#include <stdbool.h>
  14:main.c        **** 
  15:main.c        **** // Main loop
  16:main.c        **** // the AVR enters this function at boot time
  17:main.c        **** int main (void)
  18:main.c        **** {
  19:main.c        **** 	int effect_index = 0;
  20:main.c        ****     int tempval;
  21:main.c        ****     
  22:main.c        ****     // This function initiates IO ports, timers, interrupts and
  23:main.c        ****     // serial communications
  24:main.c        **** 	ioinit();
  25:main.c        **** 
  26:main.c        ****     usart_init();
  27:main.c        ****     
  28:main.c        **** 	debug_init();
  29:main.c        **** 
  30:main.c        **** 	util_init();
  31:main.c        **** 	
  32:main.c        ****     // This variable specifies which layer is currently being drawn by the
  33:main.c        **** 	// cube interrupt routine. We assign a value to it to make sure it's not >7.
  34:main.c        **** 	current_layer = 7;
  35:main.c        **** 	
  36:main.c        ****     // This variable specifies the starting mode, this can be changed by pushing the
  37:main.c        ****     // mode button or by typing in commands in the prompt.
  38:main.c        ****     current_mode = MODE_RANDOM;
  39:main.c        **** 
  40:main.c        **** 	//Binary mode
  41:main.c        **** 	binary_mode = 0;
  42:main.c        **** 
  43:main.c        **** 
  44:main.c        ****     // Reads a value from AD converter and uses it to seed the pseudo random number generator,
  45:main.c        ****     // Not perfect since AD converter returns a value from 0 to 1023 but good enough.
  46:main.c        ****     tempval = ADC_Read(7);
  47:main.c        **** 	srand(tempval);
  48:main.c        **** 
  49:main.c        **** 	// Enable interrupts
  50:main.c        **** 	// This starts the routine that draws the cube content
  51:main.c        **** 	sei();
  52:main.c        **** 
  53:main.c        **** 	// Main loop, does awesome shit forever!
  54:main.c        **** 	while (1)
  55:main.c        **** 	{
  56:main.c        ****         if(current_mode == MODE_RANDOM)
  57:main.c        ****         {
  58:main.c        ****             effect_index = rand() % EFFECTS_TOTAL;
  59:main.c        ****             
  60:main.c        ****             launch_effect(effect_index);
  61:main.c        ****         }
  62:main.c        ****         else if(current_mode == MODE_SEQUENTIAL)
  63:main.c        ****         {
  64:main.c        ****             effect_index++;
  65:main.c        ****             effect_index %= EFFECTS_TOTAL;
  66:main.c        ****             
  67:main.c        ****             launch_effect(effect_index);
  68:main.c        ****         }
  69:main.c        ****         else if(current_mode == MODE_SELF_TEST)
  70:main.c        ****         {
  71:main.c        ****             override_delay(0);
  72:main.c        ****             
  73:main.c        **** 			SelfTest();
  74:main.c        ****         }
  75:main.c        ****         else if(current_mode == MODE_MUSIC_RANDOM)
  76:main.c        ****         {
  77:main.c        ****             
  78:main.c        ****         }
  79:main.c        ****         else if(current_mode == MODE_MUSIC_SEQUENTIAL)
  80:main.c        ****         {
  81:main.c        ****             
  82:main.c        ****         }
  83:main.c        ****         else if(current_mode == MODE_BINARY)
  84:main.c        ****         {
  85:main.c        ****             rs232();
  86:main.c        ****         }
  87:main.c        ****         else
  88:main.c        ****         {
  89:main.c        ****             current_mode = MODE_RANDOM;
  90:main.c        ****         }
  91:main.c        **** 	}
  92:main.c        **** }
  93:main.c        **** 
  94:main.c        **** /*
  95:main.c        ****  * Multiplexer/framebuffer routine
  96:main.c        ****  * This function is called by an interrupt generated by timer 2.
  97:main.c        **** */
  98:main.c        **** 
  99:main.c        **** ISR(TIMER2_COMP_vect)
 100:main.c        **** {
  18               		.loc 1 100 0
  19               		.cfi_startproc
  20 0000 1F92      		push r1
  21               	.LCFI0:
  22               		.cfi_def_cfa_offset 3
  23               		.cfi_offset 1, -2
  24 0002 0F92      		push r0
  25               	.LCFI1:
  26               		.cfi_def_cfa_offset 4
  27               		.cfi_offset 0, -3
  28 0004 0FB6      		in r0,__SREG__
  29 0006 0F92      		push r0
  30 0008 1124      		clr __zero_reg__
  31 000a 2F93      		push r18
  32               	.LCFI2:
  33               		.cfi_def_cfa_offset 5
  34               		.cfi_offset 18, -4
  35 000c 8F93      		push r24
  36               	.LCFI3:
  37               		.cfi_def_cfa_offset 6
  38               		.cfi_offset 24, -5
  39 000e 9F93      		push r25
  40               	.LCFI4:
  41               		.cfi_def_cfa_offset 7
  42               		.cfi_offset 25, -6
  43 0010 EF93      		push r30
  44               	.LCFI5:
  45               		.cfi_def_cfa_offset 8
  46               		.cfi_offset 30, -7
  47 0012 FF93      		push r31
  48               	.LCFI6:
  49               		.cfi_def_cfa_offset 9
  50               		.cfi_offset 31, -8
  51               	/* prologue: Signal */
  52               	/* frame size = 0 */
  53               	/* stack size = 8 */
  54               	.L__stack_usage = 8
 101:main.c        **** 	int i;
 102:main.c        ****     
 103:main.c        ****     // Increment the current_layer counter so that the next layer is
 104:main.c        ****     // drawn the next time this function runs.
 105:main.c        ****     current_layer = (current_layer + 1) % 8;
  55               		.loc 1 105 0
  56 0014 8091 0000 		lds r24,current_layer
  57 0018 90E0      		ldi r25,lo8(0)
  58 001a 0196      		adiw r24,1
  59 001c 8770      		andi r24,lo8(7)
  60 001e 9070      		andi r25,hi8(7)
  61 0020 8093 0000 		sts current_layer,r24
 106:main.c        ****     
 107:main.c        ****     LAYER_SELECT = 0x00; // Turn all cathode layers off. (all transistors off)
  62               		.loc 1 107 0
  63 0024 18BA      		out 56-32,__zero_reg__
  64               	.LVL0:
 108:main.c        ****     
 109:main.c        ****     // Loop through all 8 bytes of data in the current layer in reverse order
 110:main.c        ****     // and shift it onto the layer.
 111:main.c        ****     for (i = 7; i >= 0; i--)
  65               		.loc 1 111 0
  66 0026 87E0      		ldi r24,lo8(7)
  67 0028 90E0      		ldi r25,hi8(7)
  68               	.LVL1:
  69               	.L2:
 112:main.c        ****     {
 113:main.c        ****         // Set the shift clock to 0
 114:main.c        ****         SHIFTCLK_ADDR &= ~SHIFTCLK_MASK;
  70               		.loc 1 114 0 discriminator 2
  71 002a 9798      		cbi 50-32,7
 115:main.c        ****         // Set the data on the data-bus of the latch array.
 116:main.c        ****         DATA_BUS = cube[current_layer][i];
  72               		.loc 1 116 0 discriminator 2
  73 002c E091 0000 		lds r30,current_layer
  74 0030 F0E0      		ldi r31,lo8(0)
  75 0032 23E0      		ldi r18,3
  76 0034 EE0F      	1:	lsl r30
  77 0036 FF1F      		rol r31
  78 0038 2A95      		dec r18
  79 003a 01F4      		brne 1b
  80 003c E80F      		add r30,r24
  81 003e F91F      		adc r31,r25
  82 0040 E050      		subi r30,lo8(-(cube))
  83 0042 F040      		sbci r31,hi8(-(cube))
  84 0044 2081      		ld r18,Z
  85 0046 25BB      		out 53-32,r18
 117:main.c        ****         // Set the shift clock to 1 to create a rising edge and shift in the data on the data bus.
 118:main.c        ****         SHIFTCLK_ADDR |= SHIFTCLK_MASK;
  86               		.loc 1 118 0 discriminator 2
  87 0048 979A      		sbi 50-32,7
 111:main.c        ****     for (i = 7; i >= 0; i--)
  88               		.loc 1 111 0 discriminator 2
  89 004a 0197      		sbiw r24,1
  90               	.LVL2:
  91 004c 2FEF      		ldi r18,hi8(-1)
  92 004e 8F3F      		cpi r24,lo8(-1)
  93 0050 9207      		cpc r25,r18
  94 0052 01F4      		brne .L2
 119:main.c        ****     }
 120:main.c        ****     
 121:main.c        ****     LAYER_SELECT = (0x01 << current_layer); // Transistor ON for current layer}
  95               		.loc 1 121 0
  96 0054 2091 0000 		lds r18,current_layer
  97 0058 81E0      		ldi r24,lo8(1)
  98 005a 90E0      		ldi r25,hi8(1)
  99               	.LVL3:
 100 005c 00C0      		rjmp 2f
 101 005e 880F      	1:	lsl r24
 102 0060 991F      		rol r25
 103 0062 2A95      	2:	dec r18
 104 0064 02F4      		brpl 1b
 105 0066 88BB      		out 56-32,r24
 106               	/* epilogue start */
 122:main.c        **** }
 107               		.loc 1 122 0
 108 0068 FF91      		pop r31
 109 006a EF91      		pop r30
 110 006c 9F91      		pop r25
 111 006e 8F91      		pop r24
 112 0070 2F91      		pop r18
 113 0072 0F90      		pop r0
 114 0074 0FBE      		out __SREG__,r0
 115 0076 0F90      		pop r0
 116 0078 1F90      		pop r1
 117 007a 1895      		reti
 118               		.cfi_endproc
 119               	.LFE2:
 121               	.global	__vector_10
 123               	__vector_10:
 124               	.LFB3:
 123:main.c        **** /*
 124:main.c        ****  * This routine does several things
 125:main.c        ****  * 1: Sends tick to the debug functions.
 126:main.c        ****  * 2: Sends tick to the delay functions.
 127:main.c        ****  * This function is called by an interrupt generated by timer 0.
 128:main.c        ****  * 
 129:main.c        **** */
 130:main.c        **** ISR(TIMER0_COMP_vect)
 131:main.c        **** {
 125               		.loc 1 131 0
 126               		.cfi_startproc
 127 007c 1F92      		push r1
 128               	.LCFI7:
 129               		.cfi_def_cfa_offset 3
 130               		.cfi_offset 1, -2
 131 007e 0F92      		push r0
 132               	.LCFI8:
 133               		.cfi_def_cfa_offset 4
 134               		.cfi_offset 0, -3
 135 0080 0FB6      		in r0,__SREG__
 136 0082 0F92      		push r0
 137 0084 1124      		clr __zero_reg__
 138 0086 2F93      		push r18
 139               	.LCFI9:
 140               		.cfi_def_cfa_offset 5
 141               		.cfi_offset 18, -4
 142 0088 3F93      		push r19
 143               	.LCFI10:
 144               		.cfi_def_cfa_offset 6
 145               		.cfi_offset 19, -5
 146 008a 4F93      		push r20
 147               	.LCFI11:
 148               		.cfi_def_cfa_offset 7
 149               		.cfi_offset 20, -6
 150 008c 5F93      		push r21
 151               	.LCFI12:
 152               		.cfi_def_cfa_offset 8
 153               		.cfi_offset 21, -7
 154 008e 6F93      		push r22
 155               	.LCFI13:
 156               		.cfi_def_cfa_offset 9
 157               		.cfi_offset 22, -8
 158 0090 7F93      		push r23
 159               	.LCFI14:
 160               		.cfi_def_cfa_offset 10
 161               		.cfi_offset 23, -9
 162 0092 8F93      		push r24
 163               	.LCFI15:
 164               		.cfi_def_cfa_offset 11
 165               		.cfi_offset 24, -10
 166 0094 9F93      		push r25
 167               	.LCFI16:
 168               		.cfi_def_cfa_offset 12
 169               		.cfi_offset 25, -11
 170 0096 AF93      		push r26
 171               	.LCFI17:
 172               		.cfi_def_cfa_offset 13
 173               		.cfi_offset 26, -12
 174 0098 BF93      		push r27
 175               	.LCFI18:
 176               		.cfi_def_cfa_offset 14
 177               		.cfi_offset 27, -13
 178 009a EF93      		push r30
 179               	.LCFI19:
 180               		.cfi_def_cfa_offset 15
 181               		.cfi_offset 30, -14
 182 009c FF93      		push r31
 183               	.LCFI20:
 184               		.cfi_def_cfa_offset 16
 185               		.cfi_offset 31, -15
 186 009e CF93      		push r28
 187               	.LCFI21:
 188               		.cfi_def_cfa_offset 17
 189               		.cfi_offset 28, -16
 190 00a0 DF93      		push r29
 191               	.LCFI22:
 192               		.cfi_def_cfa_offset 18
 193               		.cfi_offset 29, -17
 194 00a2 00D0      		rcall .
 195               	.LCFI23:
 196               		.cfi_def_cfa_offset 20
 197 00a4 CDB7      		in r28,__SP_L__
 198 00a6 DEB7      		in r29,__SP_H__
 199               	.LCFI24:
 200               		.cfi_def_cfa_register 28
 201               	/* prologue: Signal */
 202               	/* frame size = 2 */
 203               	/* stack size = 19 */
 204               	.L__stack_usage = 19
 132:main.c        **** 	bool keyPressed = false;
 205               		.loc 1 132 0
 206 00a8 1A82      		std Y+2,__zero_reg__
 207               	.LVL4:
 133:main.c        ****     bool keyChanged = false;
 208               		.loc 1 133 0
 209 00aa 1982      		std Y+1,__zero_reg__
 210               	.LVL5:
 134:main.c        ****     
 135:main.c        ****     delay_tick();
 211               		.loc 1 135 0
 212 00ac 0E94 0000 		call delay_tick
 136:main.c        **** 
 137:main.c        **** 	debug_tick();
 213               		.loc 1 137 0
 214 00b0 0E94 0000 		call debug_tick
 138:main.c        ****     
 139:main.c        ****     DebounceKey(&keyChanged, &keyPressed);
 215               		.loc 1 139 0
 216 00b4 CE01      		movw r24,r28
 217 00b6 0196      		adiw r24,1
 218 00b8 BE01      		movw r22,r28
 219 00ba 6E5F      		subi r22,lo8(-(2))
 220 00bc 7F4F      		sbci r23,hi8(-(2))
 221 00be 0E94 0000 		call DebounceKey
 140:main.c        ****     if(keyChanged && keyPressed)
 222               		.loc 1 140 0
 223 00c2 8981      		ldd r24,Y+1
 224 00c4 8823      		tst r24
 225 00c6 01F0      		breq .L4
 226               		.loc 1 140 0 is_stmt 0 discriminator 1
 227 00c8 8A81      		ldd r24,Y+2
 228 00ca 8823      		tst r24
 229 00cc 01F0      		breq .L4
 141:main.c        ****     {
 142:main.c        ****         current_mode++;
 230               		.loc 1 142 0 is_stmt 1
 231 00ce 8091 0000 		lds r24,current_mode
 232 00d2 8F5F      		subi r24,lo8(-(1))
 233 00d4 8093 0000 		sts current_mode,r24
 143:main.c        ****         current_mode %= NO_OF_MODES;
 234               		.loc 1 143 0
 235 00d8 8091 0000 		lds r24,current_mode
 236 00dc 65E0      		ldi r22,lo8(5)
 237 00de 0E94 0000 		call __udivmodqi4
 238 00e2 9093 0000 		sts current_mode,r25
 144:main.c        ****         if(current_mode == MODE_BINARY)
 239               		.loc 1 144 0
 240 00e6 8091 0000 		lds r24,current_mode
 241 00ea 8530      		cpi r24,lo8(5)
 242 00ec 01F4      		brne .L4
 145:main.c        ****         {
 146:main.c        ****             override_delay(1);
 243               		.loc 1 146 0
 244 00ee 81E0      		ldi r24,lo8(1)
 245 00f0 0E94 0000 		call override_delay
 246               	.L4:
 247               	/* epilogue start */
 147:main.c        ****         }
 148:main.c        ****     }
 149:main.c        **** }
 248               		.loc 1 149 0
 249 00f4 0F90      		pop __tmp_reg__
 250 00f6 0F90      		pop __tmp_reg__
 251 00f8 DF91      		pop r29
 252 00fa CF91      		pop r28
 253 00fc FF91      		pop r31
 254 00fe EF91      		pop r30
 255 0100 BF91      		pop r27
 256 0102 AF91      		pop r26
 257 0104 9F91      		pop r25
 258 0106 8F91      		pop r24
 259 0108 7F91      		pop r23
 260 010a 6F91      		pop r22
 261 010c 5F91      		pop r21
 262 010e 4F91      		pop r20
 263 0110 3F91      		pop r19
 264 0112 2F91      		pop r18
 265 0114 0F90      		pop r0
 266 0116 0FBE      		out __SREG__,r0
 267 0118 0F90      		pop r0
 268 011a 1F90      		pop r1
 269 011c 1895      		reti
 270               		.cfi_endproc
 271               	.LFE3:
 273               	.global	ioinit
 275               	ioinit:
 276               	.LFB4:
 150:main.c        **** 
 151:main.c        **** void ioinit (void)
 152:main.c        **** {
 277               		.loc 1 152 0
 278               		.cfi_startproc
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 281               	/* stack size = 0 */
 282               	.L__stack_usage = 0
 153:main.c        **** 	DDRA = 0x0c;    // EQ AD input and output
 283               		.loc 1 153 0
 284 011e 8CE0      		ldi r24,lo8(12)
 285 0120 8ABB      		out 58-32,r24
 154:main.c        ****     DDRB = 0xff;    // Layer select and ISP
 286               		.loc 1 154 0
 287 0122 8FEF      		ldi r24,lo8(-1)
 288 0124 87BB      		out 55-32,r24
 155:main.c        ****     DDRC = 0xff;    // Data port
 289               		.loc 1 155 0
 290 0126 84BB      		out 52-32,r24
 156:main.c        ****     DDRD = 0xf3;    // RS232, buttons, LEDS and shift clock
 291               		.loc 1 156 0
 292 0128 83EF      		ldi r24,lo8(-13)
 293 012a 81BB      		out 49-32,r24
 157:main.c        ****     
 158:main.c        ****     
 159:main.c        ****     PORTA = 0x00;   // EQ AD input pullup off? EQ outputs off
 294               		.loc 1 159 0
 295 012c 1BBA      		out 59-32,__zero_reg__
 160:main.c        ****     PORTB = 0x00;   // Layer select off
 296               		.loc 1 160 0
 297 012e 18BA      		out 56-32,__zero_reg__
 161:main.c        ****     PORTC = 0x00;   // Data port off
 298               		.loc 1 161 0
 299 0130 15BA      		out 53-32,__zero_reg__
 162:main.c        ****     PORTD = 0x04;   // All outputs off, enable pullup on button
 300               		.loc 1 162 0
 301 0132 84E0      		ldi r24,lo8(4)
 302 0134 82BB      		out 50-32,r24
 163:main.c        ****     
 164:main.c        **** 
 165:main.c        **** 	// Timer 0
 166:main.c        **** 	// General purpose timer interrupt
 167:main.c        **** 	// 14745600/64/230 = 1001 interrupts per second or 1 interrupt every 0,998ms
 168:main.c        **** 	OCR0 = 229;
 303               		.loc 1 168 0
 304 0136 85EE      		ldi r24,lo8(-27)
 305 0138 8CBF      		out 92-32,r24
 169:main.c        **** 	TCCR0 |= _BV(CS01) | _BV(CS02); // Prescaler = 64.
 306               		.loc 1 169 0
 307 013a 83B7      		in r24,83-32
 308 013c 8660      		ori r24,lo8(6)
 309 013e 83BF      		out 83-32,r24
 170:main.c        **** 	TCCR0 |= _BV(WGM01);            // CTC mode. Reset counter when OCR0 is reached.
 310               		.loc 1 170 0
 311 0140 83B7      		in r24,83-32
 312 0142 8860      		ori r24,lo8(8)
 313 0144 83BF      		out 83-32,r24
 171:main.c        **** 	TCNT0 = 0x00;                   // Initial counter value = 0;
 314               		.loc 1 171 0
 315 0146 12BE      		out 82-32,__zero_reg__
 172:main.c        **** 	TIMSK |= _BV(OCIE0);            // Enable CTC interrupt.
 316               		.loc 1 172 0
 317 0148 89B7      		in r24,89-32
 318 014a 8260      		ori r24,lo8(2)
 319 014c 89BF      		out 89-32,r24
 173:main.c        **** 
 174:main.c        **** 	// Timer 2
 175:main.c        **** 	// Frame buffer interrupt
 176:main.c        **** 	// 14745600/128/11 = 10472.72 interrupts per second
 177:main.c        **** 	// 10472.72/8 = 1309 frames per second
 178:main.c        **** 	OCR2 = 10;                      // interrupt at counter = 10
 320               		.loc 1 178 0
 321 014e 8AE0      		ldi r24,lo8(10)
 322 0150 83BD      		out 67-32,r24
 179:main.c        ****     TCCR2 |= _BV(CS20) | _BV(CS22); // Prescaler = 128.
 323               		.loc 1 179 0
 324 0152 85B5      		in r24,69-32
 325 0154 8560      		ori r24,lo8(5)
 326 0156 85BD      		out 69-32,r24
 180:main.c        **** 	TCCR2 |= _BV(WGM21);            // CTC mode. Reset counter when OCR2 is reached.
 327               		.loc 1 180 0
 328 0158 85B5      		in r24,69-32
 329 015a 8860      		ori r24,lo8(8)
 330 015c 85BD      		out 69-32,r24
 181:main.c        **** 	TCNT2 = 0x00;                   // initial counter value = 0;
 331               		.loc 1 181 0
 332 015e 14BC      		out 68-32,__zero_reg__
 182:main.c        **** 	TIMSK |= _BV(OCIE2);            // Enable CTC interrupt.
 333               		.loc 1 182 0
 334 0160 89B7      		in r24,89-32
 335 0162 8068      		ori r24,lo8(-128)
 336 0164 89BF      		out 89-32,r24
 337               	/* epilogue start */
 183:main.c        **** 
 184:main.c        **** }
 338               		.loc 1 184 0
 339 0166 0895      		ret
 340               		.cfi_endproc
 341               	.LFE4:
 343               	.global	SelfTest
 345               	SelfTest:
 346               	.LFB5:
 185:main.c        **** 
 186:main.c        **** void SelfTest()
 187:main.c        **** {
 347               		.loc 1 187 0
 348               		.cfi_startproc
 349 0168 CF92      		push r12
 350               	.LCFI25:
 351               		.cfi_def_cfa_offset 3
 352               		.cfi_offset 12, -2
 353 016a DF92      		push r13
 354               	.LCFI26:
 355               		.cfi_def_cfa_offset 4
 356               		.cfi_offset 13, -3
 357 016c EF92      		push r14
 358               	.LCFI27:
 359               		.cfi_def_cfa_offset 5
 360               		.cfi_offset 14, -4
 361 016e FF92      		push r15
 362               	.LCFI28:
 363               		.cfi_def_cfa_offset 6
 364               		.cfi_offset 15, -5
 365 0170 0F93      		push r16
 366               	.LCFI29:
 367               		.cfi_def_cfa_offset 7
 368               		.cfi_offset 16, -6
 369 0172 1F93      		push r17
 370               	.LCFI30:
 371               		.cfi_def_cfa_offset 8
 372               		.cfi_offset 17, -7
 373 0174 CF93      		push r28
 374               	.LCFI31:
 375               		.cfi_def_cfa_offset 9
 376               		.cfi_offset 28, -8
 377 0176 DF93      		push r29
 378               	.LCFI32:
 379               		.cfi_def_cfa_offset 10
 380               		.cfi_offset 29, -9
 381               	/* prologue: function */
 382               	/* frame size = 0 */
 383               	/* stack size = 8 */
 384               	.L__stack_usage = 8
 385               	.LVL6:
 188:main.c        **** 	int i, x, y;
 189:main.c        **** 
 190:main.c        **** 	for(i = 0; i < 7; i++)
 386               		.loc 1 190 0
 387 0178 C0E0      		ldi r28,lo8(0)
 388 017a D0E0      		ldi r29,hi8(0)
 389               	.LVL7:
 390               	.L8:
 191:main.c        **** 	{
 192:main.c        **** 		setplane_z(i);
 391               		.loc 1 192 0 discriminator 2
 392 017c CE01      		movw r24,r28
 393 017e 0E94 0000 		call setplane_z
 193:main.c        **** 		delay_ms(1000);	
 394               		.loc 1 193 0 discriminator 2
 395 0182 88EE      		ldi r24,lo8(1000)
 396 0184 93E0      		ldi r25,hi8(1000)
 397 0186 0E94 0000 		call delay_ms
 194:main.c        **** 		clrplane_z(i);
 398               		.loc 1 194 0 discriminator 2
 399 018a CE01      		movw r24,r28
 400 018c 0E94 0000 		call clrplane_z
 190:main.c        **** 	for(i = 0; i < 7; i++)
 401               		.loc 1 190 0 discriminator 2
 402 0190 2196      		adiw r28,1
 403               	.LVL8:
 404 0192 C730      		cpi r28,7
 405 0194 D105      		cpc r29,__zero_reg__
 406 0196 01F4      		brne .L8
 190:main.c        **** 	for(i = 0; i < 7; i++)
 407               		.loc 1 190 0 is_stmt 0
 408 0198 CC24      		clr r12
 409 019a DD24      		clr r13
 410 019c 00C0      		rjmp .L9
 411               	.LVL9:
 412               	.L10:
 195:main.c        **** 	}
 196:main.c        **** 	for(x = 0; x <= 7; x++)
 197:main.c        **** 	{
 198:main.c        **** 		for(y = 0; y <= 7; y++)
 199:main.c        **** 		{
 200:main.c        **** 			line(x, y, 0, x, y, 7);
 413               		.loc 1 200 0 is_stmt 1 discriminator 2
 414 019e C601      		movw r24,r12
 415 01a0 BE01      		movw r22,r28
 416 01a2 40E0      		ldi r20,lo8(0)
 417 01a4 50E0      		ldi r21,hi8(0)
 418 01a6 9601      		movw r18,r12
 419 01a8 8E01      		movw r16,r28
 420 01aa E7E0      		ldi r30,lo8(7)
 421 01ac EE2E      		mov r14,r30
 422 01ae F12C      		mov r15,__zero_reg__
 423 01b0 0E94 0000 		call line
 201:main.c        **** 			delay_ms(1000);
 424               		.loc 1 201 0 discriminator 2
 425 01b4 88EE      		ldi r24,lo8(1000)
 426 01b6 93E0      		ldi r25,hi8(1000)
 427 01b8 0E94 0000 		call delay_ms
 202:main.c        **** 			fill(0);
 428               		.loc 1 202 0 discriminator 2
 429 01bc 80E0      		ldi r24,lo8(0)
 430 01be 0E94 0000 		call fill
 198:main.c        **** 		for(y = 0; y <= 7; y++)
 431               		.loc 1 198 0 discriminator 2
 432 01c2 2196      		adiw r28,1
 433               	.LVL10:
 434 01c4 C830      		cpi r28,8
 435 01c6 D105      		cpc r29,__zero_reg__
 436 01c8 01F4      		brne .L10
 196:main.c        **** 	for(x = 0; x <= 7; x++)
 437               		.loc 1 196 0
 438 01ca 0894      		sec
 439 01cc C11C      		adc r12,__zero_reg__
 440 01ce D11C      		adc r13,__zero_reg__
 441               	.LVL11:
 442 01d0 88E0      		ldi r24,lo8(8)
 443 01d2 C816      		cp r12,r24
 444 01d4 D104      		cpc r13,__zero_reg__
 445 01d6 01F0      		breq .L7
 446               	.LVL12:
 447               	.L9:
 190:main.c        **** 	for(i = 0; i < 7; i++)
 448               		.loc 1 190 0 discriminator 1
 449 01d8 C0E0      		ldi r28,lo8(0)
 450 01da D0E0      		ldi r29,hi8(0)
 451 01dc 00C0      		rjmp .L10
 452               	.LVL13:
 453               	.L7:
 454               	/* epilogue start */
 203:main.c        **** 		}
 204:main.c        **** 	}
 205:main.c        **** }
 455               		.loc 1 205 0
 456 01de DF91      		pop r29
 457 01e0 CF91      		pop r28
 458               	.LVL14:
 459 01e2 1F91      		pop r17
 460 01e4 0F91      		pop r16
 461 01e6 FF90      		pop r15
 462 01e8 EF90      		pop r14
 463 01ea DF90      		pop r13
 464 01ec CF90      		pop r12
 465               	.LVL15:
 466 01ee 0895      		ret
 467               		.cfi_endproc
 468               	.LFE5:
 470               	.global	rs232
 472               	rs232:
 473               	.LFB6:
 206:main.c        **** 
 207:main.c        **** // Take input from a computer and load it onto the cube buffer
 208:main.c        **** void rs232()
 209:main.c        **** {
 474               		.loc 1 209 0
 475               		.cfi_startproc
 476 01f0 EF92      		push r14
 477               	.LCFI33:
 478               		.cfi_def_cfa_offset 3
 479               		.cfi_offset 14, -2
 480 01f2 FF92      		push r15
 481               	.LCFI34:
 482               		.cfi_def_cfa_offset 4
 483               		.cfi_offset 15, -3
 484 01f4 0F93      		push r16
 485               	.LCFI35:
 486               		.cfi_def_cfa_offset 5
 487               		.cfi_offset 16, -4
 488 01f6 1F93      		push r17
 489               	.LCFI36:
 490               		.cfi_def_cfa_offset 6
 491               		.cfi_offset 17, -5
 492 01f8 CF93      		push r28
 493               	.LCFI37:
 494               		.cfi_def_cfa_offset 7
 495               		.cfi_offset 28, -6
 496 01fa DF93      		push r29
 497               	.LCFI38:
 498               		.cfi_def_cfa_offset 8
 499               		.cfi_offset 29, -7
 500 01fc 0F92      		push __tmp_reg__
 501               	.LCFI39:
 502               		.cfi_def_cfa_offset 9
 503 01fe CDB7      		in r28,__SP_L__
 504 0200 DEB7      		in r29,__SP_H__
 505               	.LCFI40:
 506               		.cfi_def_cfa_register 28
 507 0202 00C0      		rjmp .L23
 508               	/* prologue: function */
 509               	/* frame size = 1 */
 510               	/* stack size = 7 */
 511               	.L__stack_usage = 7
 512               	.LVL16:
 513               	.L22:
 210:main.c        **** 	char tempval;
 211:main.c        **** 	int x = 0;
 212:main.c        **** 	int y = 0;
 213:main.c        ****     int escape = 0;
 214:main.c        **** 	
 215:main.c        **** 	while (current_mode == MODE_BINARY)
 216:main.c        **** 	{
 217:main.c        **** 		// Switch state on red LED for debugging
 218:main.c        **** 		// Should switch state every time the code
 219:main.c        **** 		// is waiting for a byte to be received.
 220:main.c        **** 		debug_blink(LED_RED);
 514               		.loc 1 220 0
 515 0204 80E1      		ldi r24,lo8(16)
 516 0206 0E94 0000 		call debug_blink
 517               	.L16:
 221:main.c        **** 
 222:main.c        **** 		// Wait until a byte has been received
 223:main.c        **** 		while(!HasChars());
 518               		.loc 1 223 0 discriminator 1
 519 020a 0E94 0000 		call HasChars
 520 020e 8823      		tst r24
 521 0210 01F0      		breq .L16
 224:main.c        ****         
 225:main.c        **** 		// Load the received byte from rs232 into a buffer.
 226:main.c        **** 		receive_char(&tempval);
 522               		.loc 1 226 0
 523 0212 CE01      		movw r24,r28
 524 0214 0196      		adiw r24,1
 525 0216 0E94 0000 		call receive_char
 227:main.c        **** 
 228:main.c        **** 		// Uncommet this to echo data back to the computer
 229:main.c        **** 		// for debugging purposes.
 230:main.c        **** 		//SendChar(tempval);
 231:main.c        **** 
 232:main.c        **** 		// Every time the cube receives a 0xff byte,
 233:main.c        **** 		// it goes into sync escape mode.
 234:main.c        **** 		// if a 0x00 byte is then received, the x and y counters
 235:main.c        **** 		// are reset to 0. This way the x and y counters are
 236:main.c        **** 		// always the same on the computer and in the cube.
 237:main.c        **** 		// To send an 0xff byte, you have to send it twice!
 238:main.c        **** 
 239:main.c        **** 		// Go into sync escape mode
 240:main.c        **** 		if (tempval == 0xff)
 526               		.loc 1 240 0
 527 021a 8981      		ldd r24,Y+1
 528 021c 8F3F      		cpi r24,lo8(-1)
 529 021e 01F4      		brne .L17
 530               	.L24:
 241:main.c        **** 		{
 242:main.c        ****             // Wait for the next byte
 243:main.c        ****             while(!HasChars());
 531               		.loc 1 243 0 discriminator 1
 532 0220 0E94 0000 		call HasChars
 533 0224 8823      		tst r24
 534 0226 01F0      		breq .L24
 244:main.c        ****             // Get the next byte
 245:main.c        ****             receive_char(&tempval);
 535               		.loc 1 245 0
 536 0228 CE01      		movw r24,r28
 537 022a 0196      		adiw r24,1
 538 022c 0E94 0000 		call receive_char
 246:main.c        **** 
 247:main.c        ****             // Sync signal is received.
 248:main.c        ****             // Reset x and y counters to 0.
 249:main.c        ****             if (tempval == 0x00)
 539               		.loc 1 249 0
 540 0230 8981      		ldd r24,Y+1
 541 0232 8823      		tst r24
 542 0234 01F0      		breq .L23
 543               	.L17:
 250:main.c        ****             {
 251:main.c        ****                 x = 0;
 252:main.c        **** 				y = 0;
 253:main.c        ****                 escape = 1;
 254:main.c        ****             }
 255:main.c        ****             // if no 0x00 byte is received, proceed with
 256:main.c        ****             // the byte we just received.
 257:main.c        **** 		}
 258:main.c        **** 
 259:main.c        ****         if (escape == 0)
 260:main.c        ****         {
 261:main.c        **** 			// Load data into the current position in the buffer
 262:main.c        **** 			fb[x][y] = tempval;
 544               		.loc 1 262 0
 545 0236 8981      		ldd r24,Y+1
 546 0238 F701      		movw r30,r14
 547 023a A3E0      		ldi r26,3
 548 023c EE0F      	1:	lsl r30
 549 023e FF1F      		rol r31
 550 0240 AA95      		dec r26
 551 0242 01F4      		brne 1b
 552 0244 E00F      		add r30,r16
 553 0246 F11F      		adc r31,r17
 554 0248 E050      		subi r30,lo8(-(fb))
 555 024a F040      		sbci r31,hi8(-(fb))
 556 024c 8083      		st Z,r24
 263:main.c        **** 
 264:main.c        ****     		// Check if we have reached the limits of the buffer array.
 265:main.c        ****     		if (y == 7)
 557               		.loc 1 265 0
 558 024e 0730      		cpi r16,7
 559 0250 1105      		cpc r17,__zero_reg__
 560 0252 01F4      		brne .L20
 266:main.c        ****     		{
 267:main.c        ****     			if (x == 7)
 561               		.loc 1 267 0
 562 0254 87E0      		ldi r24,lo8(7)
 563 0256 E816      		cp r14,r24
 564 0258 F104      		cpc r15,__zero_reg__
 565 025a 01F4      		brne .L21
 566               	.LVL17:
 268:main.c        ****     			{
 269:main.c        ****     				// All data is loaded. Reset both counters
 270:main.c        ****     				y = 0;
 271:main.c        ****     				x = 0;
 272:main.c        ****                     // Copy the data onto the cube.
 273:main.c        ****     				tmp2cube();
 567               		.loc 1 273 0
 568 025c 0E94 0000 		call tmp2cube
 569 0260 00C0      		rjmp .L23
 570               	.LVL18:
 571               	.L21:
 274:main.c        ****     			} 
 275:main.c        **** 				else
 276:main.c        ****     			{
 277:main.c        ****     				// A layer is loaded, reset y and increment x.
 278:main.c        ****     				x++;
 572               		.loc 1 278 0
 573 0262 0894      		sec
 574 0264 E11C      		adc r14,__zero_reg__
 575 0266 F11C      		adc r15,__zero_reg__
 576               	.LVL19:
 279:main.c        ****     				y = 0;
 577               		.loc 1 279 0
 578 0268 00E0      		ldi r16,lo8(0)
 579 026a 10E0      		ldi r17,hi8(0)
 580 026c 00C0      		rjmp .L27
 581               	.LVL20:
 582               	.L20:
 280:main.c        ****     			}
 281:main.c        ****     		} 
 282:main.c        **** 			else
 283:main.c        ****     		{
 284:main.c        ****     			// We are in the middle of loading a layer. increment y.
 285:main.c        ****     			y++;
 583               		.loc 1 285 0
 584 026e 0F5F      		subi r16,lo8(-(1))
 585 0270 1F4F      		sbci r17,hi8(-(1))
 586               	.LVL21:
 587 0272 00C0      		rjmp .L27
 588               	.LVL22:
 589               	.L23:
 252:main.c        **** 				y = 0;
 590               		.loc 1 252 0
 591 0274 00E0      		ldi r16,lo8(0)
 592 0276 10E0      		ldi r17,hi8(0)
 251:main.c        ****                 x = 0;
 593               		.loc 1 251 0
 594 0278 EE24      		clr r14
 595 027a FF24      		clr r15
 596               	.L27:
 597               	.LVL23:
 215:main.c        **** 	while (current_mode == MODE_BINARY)
 598               		.loc 1 215 0 discriminator 1
 599 027c 8091 0000 		lds r24,current_mode
 600 0280 8530      		cpi r24,lo8(5)
 601 0282 01F4      		brne .+2
 602 0284 00C0      		rjmp .L22
 603               	/* epilogue start */
 286:main.c        ****     		}
 287:main.c        **** 	
 288:main.c        **** 	    } 
 289:main.c        **** 		else
 290:main.c        ****         {
 291:main.c        ****             escape = 0;
 292:main.c        ****         }
 293:main.c        ****     }
 294:main.c        **** }
 604               		.loc 1 294 0
 605 0286 0F90      		pop __tmp_reg__
 606 0288 DF91      		pop r29
 607 028a CF91      		pop r28
 608 028c 1F91      		pop r17
 609 028e 0F91      		pop r16
 610               	.LVL24:
 611 0290 FF90      		pop r15
 612 0292 EF90      		pop r14
 613               	.LVL25:
 614 0294 0895      		ret
 615               		.cfi_endproc
 616               	.LFE6:
 618               		.section	.text.startup,"ax",@progbits
 619               	.global	main
 621               	main:
 622               	.LFB1:
  18:main.c        **** {
 623               		.loc 1 18 0
 624               		.cfi_startproc
 625               	/* prologue: function */
 626               	/* frame size = 0 */
 627               	/* stack size = 0 */
 628               	.L__stack_usage = 0
 629               	.LVL26:
  24:main.c        **** 	ioinit();
 630               		.loc 1 24 0
 631 0000 0E94 0000 		call ioinit
  26:main.c        ****     usart_init();
 632               		.loc 1 26 0
 633 0004 0E94 0000 		call usart_init
  28:main.c        **** 	debug_init();
 634               		.loc 1 28 0
 635 0008 0E94 0000 		call debug_init
  30:main.c        **** 	util_init();
 636               		.loc 1 30 0
 637 000c 0E94 0000 		call util_init
  34:main.c        **** 	current_layer = 7;
 638               		.loc 1 34 0
 639 0010 87E0      		ldi r24,lo8(7)
 640 0012 8093 0000 		sts current_layer,r24
  38:main.c        ****     current_mode = MODE_RANDOM;
 641               		.loc 1 38 0
 642 0016 1092 0000 		sts current_mode,__zero_reg__
  41:main.c        **** 	binary_mode = 0;
 643               		.loc 1 41 0
 644 001a 1092 0000 		sts binary_mode,__zero_reg__
  46:main.c        ****     tempval = ADC_Read(7);
 645               		.loc 1 46 0
 646 001e 0E94 0000 		call ADC_Read
 647               	.LVL27:
  47:main.c        **** 	srand(tempval);
 648               		.loc 1 47 0
 649 0022 0E94 0000 		call srand
 650               	.LVL28:
  51:main.c        **** 	sei();
 651               		.loc 1 51 0
 652               	/* #APP */
 653               	 ;  51 "main.c" 1
 654 0026 7894      		sei
 655               	 ;  0 "" 2
  19:main.c        **** 	int effect_index = 0;
 656               		.loc 1 19 0
 657               	/* #NOAPP */
 658 0028 C0E0      		ldi r28,lo8(0)
 659 002a D0E0      		ldi r29,hi8(0)
  58:main.c        ****             effect_index = rand() % EFFECTS_TOTAL;
 660               		.loc 1 58 0
 661 002c 0BE1      		ldi r16,lo8(27)
 662 002e 10E0      		ldi r17,hi8(27)
 663               	.LVL29:
 664               	.L37:
  56:main.c        ****         if(current_mode == MODE_RANDOM)
 665               		.loc 1 56 0
 666 0030 8091 0000 		lds r24,current_mode
 667 0034 8823      		tst r24
 668 0036 01F4      		brne .L30
  58:main.c        ****             effect_index = rand() % EFFECTS_TOTAL;
 669               		.loc 1 58 0
 670 0038 0E94 0000 		call rand
 671 003c 00C0      		rjmp .L38
 672               	.L30:
  62:main.c        ****         else if(current_mode == MODE_SEQUENTIAL)
 673               		.loc 1 62 0
 674 003e 8091 0000 		lds r24,current_mode
 675 0042 8130      		cpi r24,lo8(1)
 676 0044 01F4      		brne .L32
  64:main.c        ****             effect_index++;
 677               		.loc 1 64 0
 678 0046 CE01      		movw r24,r28
 679 0048 0196      		adiw r24,1
 680               	.L38:
 681               	.LVL30:
  65:main.c        ****             effect_index %= EFFECTS_TOTAL;
 682               		.loc 1 65 0
 683 004a B801      		movw r22,r16
 684 004c 0E94 0000 		call __divmodhi4
 685               	.LVL31:
 686 0050 EC01      		movw r28,r24
 687               	.LVL32:
  67:main.c        ****             launch_effect(effect_index);
 688               		.loc 1 67 0
 689 0052 0E94 0000 		call launch_effect
 690               	.LVL33:
 691 0056 00C0      		rjmp .L37
 692               	.L32:
  69:main.c        ****         else if(current_mode == MODE_SELF_TEST)
 693               		.loc 1 69 0
 694 0058 8091 0000 		lds r24,current_mode
 695 005c 8230      		cpi r24,lo8(2)
 696 005e 01F4      		brne .L33
  71:main.c        ****             override_delay(0);
 697               		.loc 1 71 0
 698 0060 80E0      		ldi r24,lo8(0)
 699 0062 0E94 0000 		call override_delay
  73:main.c        **** 			SelfTest();
 700               		.loc 1 73 0
 701 0066 0E94 0000 		call SelfTest
 702 006a 00C0      		rjmp .L37
 703               	.L33:
  75:main.c        ****         else if(current_mode == MODE_MUSIC_RANDOM)
 704               		.loc 1 75 0
 705 006c 8091 0000 		lds r24,current_mode
 706 0070 8330      		cpi r24,lo8(3)
 707 0072 01F0      		breq .L37
  79:main.c        ****         else if(current_mode == MODE_MUSIC_SEQUENTIAL)
 708               		.loc 1 79 0
 709 0074 8091 0000 		lds r24,current_mode
 710 0078 8430      		cpi r24,lo8(4)
 711 007a 01F0      		breq .L37
  83:main.c        ****         else if(current_mode == MODE_BINARY)
 712               		.loc 1 83 0
 713 007c 8091 0000 		lds r24,current_mode
 714 0080 8530      		cpi r24,lo8(5)
 715 0082 01F4      		brne .L34
  85:main.c        ****             rs232();
 716               		.loc 1 85 0
 717 0084 0E94 0000 		call rs232
 718 0088 00C0      		rjmp .L37
 719               	.L34:
  89:main.c        ****             current_mode = MODE_RANDOM;
 720               		.loc 1 89 0
 721 008a 1092 0000 		sts current_mode,__zero_reg__
 722 008e 00C0      		rjmp .L37
 723               		.cfi_endproc
 724               	.LFE1:
 726               		.comm binary_mode,1,1
 727               	.global	RandomSeed_ptr
 728               		.section	.eeprom,"aw",@progbits
 731               	RandomSeed_ptr:
 732 0000 0000      		.skip 2,0
 733               		.comm current_mode,1,1
 734               		.comm current_layer,1,1
 735               		.comm fb,64,1
 736               		.comm cube,64,1
 737               		.text
 738               	.Letext0:
 739               		.file 2 "/usr/local/CrossPack-AVR-20130212/lib/gcc/avr/4.6.2/../../../../avr/include/stdint.h"
 740               		.file 3 "cube.h"
 741               		.file 4 "main.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccjH0JG4.s:2      *ABS*:0000003f __SREG__
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccjH0JG4.s:3      *ABS*:0000003e __SP_H__
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccjH0JG4.s:4      *ABS*:0000003d __SP_L__
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccjH0JG4.s:5      *ABS*:00000034 __CCP__
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccjH0JG4.s:6      *ABS*:00000000 __tmp_reg__
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccjH0JG4.s:7      *ABS*:00000001 __zero_reg__
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccjH0JG4.s:15     .text:00000000 __vector_4
                            *COM*:00000001 current_layer
                            *COM*:00000040 cube
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccjH0JG4.s:123    .text:0000007c __vector_10
                            *COM*:00000001 current_mode
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccjH0JG4.s:275    .text:0000011e ioinit
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccjH0JG4.s:345    .text:00000168 SelfTest
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccjH0JG4.s:472    .text:000001f0 rs232
                            *COM*:00000040 fb
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccjH0JG4.s:621    .text.startup:00000000 main
                            *COM*:00000001 binary_mode
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccjH0JG4.s:731    .eeprom:00000000 RandomSeed_ptr

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
delay_tick
debug_tick
DebounceKey
__udivmodqi4
override_delay
setplane_z
delay_ms
clrplane_z
line
fill
debug_blink
HasChars
receive_char
tmp2cube
usart_init
debug_init
util_init
ADC_Read
srand
rand
__divmodhi4
launch_effect
