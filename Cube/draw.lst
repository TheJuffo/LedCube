   1               		.file	"draw.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  13               	.global	inrange
  15               	inrange:
  16               	.LFB5:
  17               		.file 1 "draw.c"
   1:draw.c        **** #include "draw.h"
   2:draw.c        **** #include "string.h"
   3:draw.c        **** 
   4:draw.c        **** // Set a single voxel to ON
   5:draw.c        **** void setvoxel(int x, int y, int z)
   6:draw.c        **** {
   7:draw.c        **** 	if (inrange(x,y,z))
   8:draw.c        **** 		cube[z][y] |= (1 << x);
   9:draw.c        **** }
  10:draw.c        **** 
  11:draw.c        **** // Set a single voxel in the temporary cube buffer to ON
  12:draw.c        **** void tmpsetvoxel(int x, int y, int z)
  13:draw.c        **** {
  14:draw.c        **** 	if (inrange(x,y,z))
  15:draw.c        **** 		fb[z][y] |= (1 << x);
  16:draw.c        **** }
  17:draw.c        **** 
  18:draw.c        **** // Set a single voxel to OFF
  19:draw.c        **** void clrvoxel(int x, int y, int z)
  20:draw.c        **** {
  21:draw.c        **** 	if (inrange(x,y,z))
  22:draw.c        **** 		cube[z][y] &= ~(1 << x);
  23:draw.c        **** }
  24:draw.c        **** 
  25:draw.c        **** // Set a single voxel to OFF
  26:draw.c        **** void tmpclrvoxel(int x, int y, int z)
  27:draw.c        **** {
  28:draw.c        **** 	if (inrange(x,y,z))
  29:draw.c        **** 		fb[z][y] &= ~(1 << x);
  30:draw.c        **** }
  31:draw.c        **** 
  32:draw.c        **** // This function validates that we are drawing inside the cube.
  33:draw.c        **** unsigned char inrange(int x, int y, int z)
  34:draw.c        **** {
  18               		.loc 1 34 0
  19               		.cfi_startproc
  20               	.LVL0:
  21               	/* prologue: function */
  22               	/* frame size = 0 */
  23               	/* stack size = 0 */
  24               	.L__stack_usage = 0
  35:draw.c        **** 	if (x >= 0 && x < CUBE_SIZE && y >= 0 && y < CUBE_SIZE && z >= 0 && z < CUBE_SIZE)
  25               		.loc 1 35 0
  26 0000 8830      		cpi r24,8
  27 0002 9105      		cpc r25,__zero_reg__
  28 0004 00F4      		brsh .L6
  29               		.loc 1 35 0 is_stmt 0 discriminator 1
  30 0006 77FD      		sbrc r23,7
  31 0008 00C0      		rjmp .L6
  32 000a 6830      		cpi r22,8
  33 000c 7105      		cpc r23,__zero_reg__
  34 000e 04F4      		brge .L6
  35 0010 57FD      		sbrc r21,7
  36 0012 00C0      		rjmp .L7
  33:draw.c        **** unsigned char inrange(int x, int y, int z)
  37               		.loc 1 33 0 is_stmt 1 discriminator 1
  38 0014 81E0      		ldi r24,lo8(1)
  39               	.LVL1:
  40 0016 4830      		cpi r20,8
  41 0018 5105      		cpc r21,__zero_reg__
  42 001a 04F0      		brlt .L2
  43               	.L6:
  36:draw.c        **** 	{
  37:draw.c        **** 		return 1;
  38:draw.c        **** 	} else
  39:draw.c        **** 	{
  40:draw.c        **** 		// One of the coordinates was outside the cube.
  41:draw.c        **** 		return 0;
  44               		.loc 1 41 0
  45 001c 80E0      		ldi r24,lo8(0)
  46 001e 0895      		ret
  47               	.LVL2:
  48               	.L7:
  49 0020 80E0      		ldi r24,lo8(0)
  50               	.LVL3:
  51               	.L2:
  42:draw.c        **** 	}
  43:draw.c        **** }
  52               		.loc 1 43 0
  53 0022 0895      		ret
  54               		.cfi_endproc
  55               	.LFE5:
  57               	.global	tmpclrvoxel
  59               	tmpclrvoxel:
  60               	.LFB4:
  27:draw.c        **** {
  61               		.loc 1 27 0
  62               		.cfi_startproc
  63               	.LVL4:
  64 0024 EF92      		push r14
  65               	.LCFI0:
  66               		.cfi_def_cfa_offset 3
  67               		.cfi_offset 14, -2
  68 0026 FF92      		push r15
  69               	.LCFI1:
  70               		.cfi_def_cfa_offset 4
  71               		.cfi_offset 15, -3
  72 0028 1F93      		push r17
  73               	.LCFI2:
  74               		.cfi_def_cfa_offset 5
  75               		.cfi_offset 17, -4
  76 002a CF93      		push r28
  77               	.LCFI3:
  78               		.cfi_def_cfa_offset 6
  79               		.cfi_offset 28, -5
  80 002c DF93      		push r29
  81               	.LCFI4:
  82               		.cfi_def_cfa_offset 7
  83               		.cfi_offset 29, -6
  84               	/* prologue: function */
  85               	/* frame size = 0 */
  86               	/* stack size = 5 */
  87               	.L__stack_usage = 5
  88 002e 182F      		mov r17,r24
  89 0030 7B01      		movw r14,r22
  90 0032 EA01      		movw r28,r20
  28:draw.c        **** 	if (inrange(x,y,z))
  91               		.loc 1 28 0
  92 0034 0E94 0000 		call inrange
  93               	.LVL5:
  94 0038 8823      		tst r24
  95 003a 01F0      		breq .L8
  29:draw.c        **** 		fb[z][y] &= ~(1 << x);
  96               		.loc 1 29 0
  97 003c 83E0      		ldi r24,3
  98 003e CC0F      	1:	lsl r28
  99 0040 DD1F      		rol r29
 100 0042 8A95      		dec r24
 101 0044 01F4      		brne 1b
 102               	.LVL6:
 103 0046 CE0D      		add r28,r14
 104 0048 DF1D      		adc r29,r15
 105 004a C050      		subi r28,lo8(-(fb))
 106 004c D040      		sbci r29,hi8(-(fb))
 107 004e 2881      		ld r18,Y
 108 0050 81E0      		ldi r24,lo8(1)
 109 0052 90E0      		ldi r25,hi8(1)
 110 0054 00C0      		rjmp 2f
 111 0056 880F      	1:	lsl r24
 112 0058 991F      		rol r25
 113 005a 1A95      	2:	dec r17
 114 005c 02F4      		brpl 1b
 115 005e 8095      		com r24
 116 0060 8223      		and r24,r18
 117 0062 8883      		st Y,r24
 118               	.L8:
 119               	/* epilogue start */
  30:draw.c        **** }
 120               		.loc 1 30 0
 121 0064 DF91      		pop r29
 122 0066 CF91      		pop r28
 123 0068 1F91      		pop r17
 124 006a FF90      		pop r15
 125 006c EF90      		pop r14
 126               	.LVL7:
 127 006e 0895      		ret
 128               		.cfi_endproc
 129               	.LFE4:
 131               	.global	clrvoxel
 133               	clrvoxel:
 134               	.LFB3:
  20:draw.c        **** {
 135               		.loc 1 20 0
 136               		.cfi_startproc
 137               	.LVL8:
 138 0070 EF92      		push r14
 139               	.LCFI5:
 140               		.cfi_def_cfa_offset 3
 141               		.cfi_offset 14, -2
 142 0072 FF92      		push r15
 143               	.LCFI6:
 144               		.cfi_def_cfa_offset 4
 145               		.cfi_offset 15, -3
 146 0074 1F93      		push r17
 147               	.LCFI7:
 148               		.cfi_def_cfa_offset 5
 149               		.cfi_offset 17, -4
 150 0076 CF93      		push r28
 151               	.LCFI8:
 152               		.cfi_def_cfa_offset 6
 153               		.cfi_offset 28, -5
 154 0078 DF93      		push r29
 155               	.LCFI9:
 156               		.cfi_def_cfa_offset 7
 157               		.cfi_offset 29, -6
 158               	/* prologue: function */
 159               	/* frame size = 0 */
 160               	/* stack size = 5 */
 161               	.L__stack_usage = 5
 162 007a 182F      		mov r17,r24
 163 007c 7B01      		movw r14,r22
 164 007e EA01      		movw r28,r20
  21:draw.c        **** 	if (inrange(x,y,z))
 165               		.loc 1 21 0
 166 0080 0E94 0000 		call inrange
 167               	.LVL9:
 168 0084 8823      		tst r24
 169 0086 01F0      		breq .L10
  22:draw.c        **** 		cube[z][y] &= ~(1 << x);
 170               		.loc 1 22 0
 171 0088 93E0      		ldi r25,3
 172 008a CC0F      	1:	lsl r28
 173 008c DD1F      		rol r29
 174 008e 9A95      		dec r25
 175 0090 01F4      		brne 1b
 176               	.LVL10:
 177 0092 CE0D      		add r28,r14
 178 0094 DF1D      		adc r29,r15
 179 0096 C050      		subi r28,lo8(-(cube))
 180 0098 D040      		sbci r29,hi8(-(cube))
 181 009a 2881      		ld r18,Y
 182 009c 81E0      		ldi r24,lo8(1)
 183 009e 90E0      		ldi r25,hi8(1)
 184 00a0 00C0      		rjmp 2f
 185 00a2 880F      	1:	lsl r24
 186 00a4 991F      		rol r25
 187 00a6 1A95      	2:	dec r17
 188 00a8 02F4      		brpl 1b
 189 00aa 8095      		com r24
 190 00ac 8223      		and r24,r18
 191 00ae 8883      		st Y,r24
 192               	.L10:
 193               	/* epilogue start */
  23:draw.c        **** }
 194               		.loc 1 23 0
 195 00b0 DF91      		pop r29
 196 00b2 CF91      		pop r28
 197 00b4 1F91      		pop r17
 198 00b6 FF90      		pop r15
 199 00b8 EF90      		pop r14
 200               	.LVL11:
 201 00ba 0895      		ret
 202               		.cfi_endproc
 203               	.LFE3:
 205               	.global	tmpsetvoxel
 207               	tmpsetvoxel:
 208               	.LFB2:
  13:draw.c        **** {
 209               		.loc 1 13 0
 210               		.cfi_startproc
 211               	.LVL12:
 212 00bc EF92      		push r14
 213               	.LCFI10:
 214               		.cfi_def_cfa_offset 3
 215               		.cfi_offset 14, -2
 216 00be FF92      		push r15
 217               	.LCFI11:
 218               		.cfi_def_cfa_offset 4
 219               		.cfi_offset 15, -3
 220 00c0 1F93      		push r17
 221               	.LCFI12:
 222               		.cfi_def_cfa_offset 5
 223               		.cfi_offset 17, -4
 224 00c2 CF93      		push r28
 225               	.LCFI13:
 226               		.cfi_def_cfa_offset 6
 227               		.cfi_offset 28, -5
 228 00c4 DF93      		push r29
 229               	.LCFI14:
 230               		.cfi_def_cfa_offset 7
 231               		.cfi_offset 29, -6
 232               	/* prologue: function */
 233               	/* frame size = 0 */
 234               	/* stack size = 5 */
 235               	.L__stack_usage = 5
 236 00c6 182F      		mov r17,r24
 237 00c8 7B01      		movw r14,r22
 238 00ca EA01      		movw r28,r20
  14:draw.c        **** 	if (inrange(x,y,z))
 239               		.loc 1 14 0
 240 00cc 0E94 0000 		call inrange
 241               	.LVL13:
 242 00d0 8823      		tst r24
 243 00d2 01F0      		breq .L12
  15:draw.c        **** 		fb[z][y] |= (1 << x);
 244               		.loc 1 15 0
 245 00d4 23E0      		ldi r18,3
 246 00d6 CC0F      	1:	lsl r28
 247 00d8 DD1F      		rol r29
 248 00da 2A95      		dec r18
 249 00dc 01F4      		brne 1b
 250               	.LVL14:
 251 00de CE0D      		add r28,r14
 252 00e0 DF1D      		adc r29,r15
 253 00e2 C050      		subi r28,lo8(-(fb))
 254 00e4 D040      		sbci r29,hi8(-(fb))
 255 00e6 2881      		ld r18,Y
 256 00e8 81E0      		ldi r24,lo8(1)
 257 00ea 90E0      		ldi r25,hi8(1)
 258 00ec 00C0      		rjmp 2f
 259 00ee 880F      	1:	lsl r24
 260 00f0 991F      		rol r25
 261 00f2 1A95      	2:	dec r17
 262 00f4 02F4      		brpl 1b
 263 00f6 282B      		or r18,r24
 264 00f8 2883      		st Y,r18
 265               	.L12:
 266               	/* epilogue start */
  16:draw.c        **** }
 267               		.loc 1 16 0
 268 00fa DF91      		pop r29
 269 00fc CF91      		pop r28
 270 00fe 1F91      		pop r17
 271 0100 FF90      		pop r15
 272 0102 EF90      		pop r14
 273               	.LVL15:
 274 0104 0895      		ret
 275               		.cfi_endproc
 276               	.LFE2:
 278               	.global	setvoxel
 280               	setvoxel:
 281               	.LFB1:
   6:draw.c        **** {
 282               		.loc 1 6 0
 283               		.cfi_startproc
 284               	.LVL16:
 285 0106 EF92      		push r14
 286               	.LCFI15:
 287               		.cfi_def_cfa_offset 3
 288               		.cfi_offset 14, -2
 289 0108 FF92      		push r15
 290               	.LCFI16:
 291               		.cfi_def_cfa_offset 4
 292               		.cfi_offset 15, -3
 293 010a 1F93      		push r17
 294               	.LCFI17:
 295               		.cfi_def_cfa_offset 5
 296               		.cfi_offset 17, -4
 297 010c CF93      		push r28
 298               	.LCFI18:
 299               		.cfi_def_cfa_offset 6
 300               		.cfi_offset 28, -5
 301 010e DF93      		push r29
 302               	.LCFI19:
 303               		.cfi_def_cfa_offset 7
 304               		.cfi_offset 29, -6
 305               	/* prologue: function */
 306               	/* frame size = 0 */
 307               	/* stack size = 5 */
 308               	.L__stack_usage = 5
 309 0110 182F      		mov r17,r24
 310 0112 7B01      		movw r14,r22
 311 0114 EA01      		movw r28,r20
   7:draw.c        **** 	if (inrange(x,y,z))
 312               		.loc 1 7 0
 313 0116 0E94 0000 		call inrange
 314               	.LVL17:
 315 011a 8823      		tst r24
 316 011c 01F0      		breq .L14
   8:draw.c        **** 		cube[z][y] |= (1 << x);
 317               		.loc 1 8 0
 318 011e 33E0      		ldi r19,3
 319 0120 CC0F      	1:	lsl r28
 320 0122 DD1F      		rol r29
 321 0124 3A95      		dec r19
 322 0126 01F4      		brne 1b
 323               	.LVL18:
 324 0128 CE0D      		add r28,r14
 325 012a DF1D      		adc r29,r15
 326 012c C050      		subi r28,lo8(-(cube))
 327 012e D040      		sbci r29,hi8(-(cube))
 328 0130 2881      		ld r18,Y
 329 0132 81E0      		ldi r24,lo8(1)
 330 0134 90E0      		ldi r25,hi8(1)
 331 0136 00C0      		rjmp 2f
 332 0138 880F      	1:	lsl r24
 333 013a 991F      		rol r25
 334 013c 1A95      	2:	dec r17
 335 013e 02F4      		brpl 1b
 336 0140 282B      		or r18,r24
 337 0142 2883      		st Y,r18
 338               	.L14:
 339               	/* epilogue start */
   9:draw.c        **** }
 340               		.loc 1 9 0
 341 0144 DF91      		pop r29
 342 0146 CF91      		pop r28
 343 0148 1F91      		pop r17
 344 014a FF90      		pop r15
 345 014c EF90      		pop r14
 346               	.LVL19:
 347 014e 0895      		ret
 348               		.cfi_endproc
 349               	.LFE1:
 351               	.global	getvoxel
 353               	getvoxel:
 354               	.LFB6:
  44:draw.c        **** 
  45:draw.c        **** // Get the current status of a voxel
  46:draw.c        **** unsigned char getvoxel(int x, int y, int z)
  47:draw.c        **** {
 355               		.loc 1 47 0
 356               		.cfi_startproc
 357               	.LVL20:
 358 0150 EF92      		push r14
 359               	.LCFI20:
 360               		.cfi_def_cfa_offset 3
 361               		.cfi_offset 14, -2
 362 0152 FF92      		push r15
 363               	.LCFI21:
 364               		.cfi_def_cfa_offset 4
 365               		.cfi_offset 15, -3
 366 0154 1F93      		push r17
 367               	.LCFI22:
 368               		.cfi_def_cfa_offset 5
 369               		.cfi_offset 17, -4
 370 0156 CF93      		push r28
 371               	.LCFI23:
 372               		.cfi_def_cfa_offset 6
 373               		.cfi_offset 28, -5
 374 0158 DF93      		push r29
 375               	.LCFI24:
 376               		.cfi_def_cfa_offset 7
 377               		.cfi_offset 29, -6
 378               	/* prologue: function */
 379               	/* frame size = 0 */
 380               	/* stack size = 5 */
 381               	.L__stack_usage = 5
 382 015a 182F      		mov r17,r24
 383 015c 7B01      		movw r14,r22
 384 015e EA01      		movw r28,r20
  48:draw.c        **** 	if (inrange(x,y,z))
 385               		.loc 1 48 0
 386 0160 0E94 0000 		call inrange
 387               	.LVL21:
 388 0164 8823      		tst r24
 389 0166 01F0      		breq .L18
  49:draw.c        **** 	{
  50:draw.c        **** 		if (cube[z][y] & (1 << x))
 390               		.loc 1 50 0
 391 0168 43E0      		ldi r20,3
 392 016a CC0F      	1:	lsl r28
 393 016c DD1F      		rol r29
 394 016e 4A95      		dec r20
 395 0170 01F4      		brne 1b
 396               	.LVL22:
 397 0172 CE0D      		add r28,r14
 398 0174 DF1D      		adc r29,r15
 399 0176 C050      		subi r28,lo8(-(cube))
 400 0178 D040      		sbci r29,hi8(-(cube))
 401 017a 8881      		ld r24,Y
 402 017c 90E0      		ldi r25,lo8(0)
 403 017e 00C0      		rjmp 2f
 404 0180 9595      	1:	asr r25
 405 0182 8795      		ror r24
 406 0184 1A95      	2:	dec r17
 407 0186 02F4      		brpl 1b
  51:draw.c        **** 		{
  52:draw.c        **** 			return 1;
 408               		.loc 1 52 0
 409 0188 8170      		andi r24,lo8(1)
 410 018a 00C0      		rjmp .L17
 411               	.LVL23:
 412               	.L18:
  53:draw.c        **** 		} else
  54:draw.c        **** 		{
  55:draw.c        **** 			return 0;
  56:draw.c        **** 		}
  57:draw.c        **** 	} else
  58:draw.c        **** 	{
  59:draw.c        **** 		return 0;
 413               		.loc 1 59 0
 414 018c 80E0      		ldi r24,lo8(0)
 415               	.LVL24:
 416               	.L17:
 417               	/* epilogue start */
  60:draw.c        **** 	}
  61:draw.c        **** }
 418               		.loc 1 61 0
 419 018e DF91      		pop r29
 420 0190 CF91      		pop r28
 421 0192 1F91      		pop r17
 422 0194 FF90      		pop r15
 423 0196 EF90      		pop r14
 424               	.LVL25:
 425 0198 0895      		ret
 426               		.cfi_endproc
 427               	.LFE6:
 429               	.global	altervoxel
 431               	altervoxel:
 432               	.LFB7:
  62:draw.c        **** 
  63:draw.c        **** // In some effect we want to just take bool and write it to a voxel
  64:draw.c        **** // this function calls the apropriate voxel manipulation function.
  65:draw.c        **** void altervoxel(int x, int y, int z, int state)
  66:draw.c        **** {
 433               		.loc 1 66 0
 434               		.cfi_startproc
 435               	.LVL26:
 436               	/* prologue: function */
 437               	/* frame size = 0 */
 438               	/* stack size = 0 */
 439               	.L__stack_usage = 0
  67:draw.c        **** 	if (state == 1)
 440               		.loc 1 67 0
 441 019a 2130      		cpi r18,1
 442 019c 3105      		cpc r19,__zero_reg__
 443 019e 01F4      		brne .L20
  68:draw.c        **** 	{
  69:draw.c        **** 		setvoxel(x,y,z);
 444               		.loc 1 69 0
 445 01a0 0E94 0000 		call setvoxel
 446               	.LVL27:
 447 01a4 0895      		ret
 448               	.LVL28:
 449               	.L20:
  70:draw.c        **** 	} else
  71:draw.c        **** 	{
  72:draw.c        **** 		clrvoxel(x,y,z);
 450               		.loc 1 72 0
 451 01a6 0E94 0000 		call clrvoxel
 452               	.LVL29:
 453 01aa 0895      		ret
 454               		.cfi_endproc
 455               	.LFE7:
 457               	.global	flpvoxel
 459               	flpvoxel:
 460               	.LFB8:
  73:draw.c        **** 	}
  74:draw.c        **** }
  75:draw.c        **** 
  76:draw.c        **** // Flip the state of a voxel.
  77:draw.c        **** // If the voxel is 1, its turned into a 0, and vice versa.
  78:draw.c        **** void flpvoxel(int x, int y, int z)
  79:draw.c        **** {
 461               		.loc 1 79 0
 462               		.cfi_startproc
 463               	.LVL30:
 464 01ac EF92      		push r14
 465               	.LCFI25:
 466               		.cfi_def_cfa_offset 3
 467               		.cfi_offset 14, -2
 468 01ae FF92      		push r15
 469               	.LCFI26:
 470               		.cfi_def_cfa_offset 4
 471               		.cfi_offset 15, -3
 472 01b0 1F93      		push r17
 473               	.LCFI27:
 474               		.cfi_def_cfa_offset 5
 475               		.cfi_offset 17, -4
 476 01b2 CF93      		push r28
 477               	.LCFI28:
 478               		.cfi_def_cfa_offset 6
 479               		.cfi_offset 28, -5
 480 01b4 DF93      		push r29
 481               	.LCFI29:
 482               		.cfi_def_cfa_offset 7
 483               		.cfi_offset 29, -6
 484               	/* prologue: function */
 485               	/* frame size = 0 */
 486               	/* stack size = 5 */
 487               	.L__stack_usage = 5
 488 01b6 182F      		mov r17,r24
 489 01b8 7B01      		movw r14,r22
 490 01ba EA01      		movw r28,r20
  80:draw.c        **** 	if (inrange(x, y, z))
 491               		.loc 1 80 0
 492 01bc 0E94 0000 		call inrange
 493               	.LVL31:
 494 01c0 8823      		tst r24
 495 01c2 01F0      		breq .L22
  81:draw.c        **** 		cube[z][y] ^= (1 << x);
 496               		.loc 1 81 0
 497 01c4 53E0      		ldi r21,3
 498 01c6 CC0F      	1:	lsl r28
 499 01c8 DD1F      		rol r29
 500 01ca 5A95      		dec r21
 501 01cc 01F4      		brne 1b
 502               	.LVL32:
 503 01ce CE0D      		add r28,r14
 504 01d0 DF1D      		adc r29,r15
 505 01d2 C050      		subi r28,lo8(-(cube))
 506 01d4 D040      		sbci r29,hi8(-(cube))
 507 01d6 2881      		ld r18,Y
 508 01d8 81E0      		ldi r24,lo8(1)
 509 01da 90E0      		ldi r25,hi8(1)
 510 01dc 00C0      		rjmp 2f
 511 01de 880F      	1:	lsl r24
 512 01e0 991F      		rol r25
 513 01e2 1A95      	2:	dec r17
 514 01e4 02F4      		brpl 1b
 515 01e6 2827      		eor r18,r24
 516 01e8 2883      		st Y,r18
 517               	.L22:
 518               	/* epilogue start */
  82:draw.c        **** }
 519               		.loc 1 82 0
 520 01ea DF91      		pop r29
 521 01ec CF91      		pop r28
 522 01ee 1F91      		pop r17
 523 01f0 FF90      		pop r15
 524 01f2 EF90      		pop r14
 525               	.LVL33:
 526 01f4 0895      		ret
 527               		.cfi_endproc
 528               	.LFE8:
 530               	.global	argorder
 532               	argorder:
 533               	.LFB9:
  83:draw.c        **** 
  84:draw.c        **** // Makes sure x1 is alwas smaller than x2
  85:draw.c        **** // This is usefull for functions that uses for loops,
  86:draw.c        **** // to avoid infinite loops
  87:draw.c        **** void argorder(int ix1, int ix2, int *ox1, int *ox2)
  88:draw.c        **** {
 534               		.loc 1 88 0
 535               		.cfi_startproc
 536               	.LVL34:
 537               	/* prologue: function */
 538               	/* frame size = 0 */
 539               	/* stack size = 0 */
 540               	.L__stack_usage = 0
  89:draw.c        **** 	if (ix1 > ix2)
 541               		.loc 1 89 0
 542 01f6 6817      		cp r22,r24
 543 01f8 7907      		cpc r23,r25
 544 01fa 04F4      		brge .L25
 545 01fc F82F      		mov r31,r24
 546 01fe E92F      		mov r30,r25
 547 0200 CB01      		movw r24,r22
 548               	.LVL35:
 549 0202 6F2F      		mov r22,r31
 550               	.LVL36:
 551 0204 7E2F      		mov r23,r30
 552               	.LVL37:
 553               	.L25:
  90:draw.c        **** 	{
  91:draw.c        **** 		int tmp;
  92:draw.c        **** 		tmp = ix1;
  93:draw.c        **** 		ix1= ix2;
  94:draw.c        **** 		ix2 = tmp;
  95:draw.c        **** 	}
  96:draw.c        **** 	*ox1 = ix1;
 554               		.loc 1 96 0
 555 0206 FA01      		movw r30,r20
 556 0208 9183      		std Z+1,r25
 557 020a 8083      		st Z,r24
  97:draw.c        **** 	*ox2 = ix2;
 558               		.loc 1 97 0
 559 020c F901      		movw r30,r18
 560 020e 7183      		std Z+1,r23
 561 0210 6083      		st Z,r22
 562               	/* epilogue start */
  98:draw.c        **** }
 563               		.loc 1 98 0
 564 0212 0895      		ret
 565               		.cfi_endproc
 566               	.LFE9:
 568               	.global	setplane_z
 570               	setplane_z:
 571               	.LFB10:
  99:draw.c        **** 
 100:draw.c        **** // Sets all voxels along a X/Y plane at a given point
 101:draw.c        **** // on axis Z
 102:draw.c        **** void setplane_z (int z)
 103:draw.c        **** {
 572               		.loc 1 103 0
 573               		.cfi_startproc
 574               	.LVL38:
 575               	/* prologue: function */
 576               	/* frame size = 0 */
 577               	/* stack size = 0 */
 578               	.L__stack_usage = 0
 104:draw.c        **** 	int i;
 105:draw.c        **** 	if (z >= 0 && z < CUBE_SIZE)
 579               		.loc 1 105 0
 580 0214 8830      		cpi r24,8
 581 0216 9105      		cpc r25,__zero_reg__
 582 0218 00F4      		brsh .L27
 106:draw.c        **** 	{
 107:draw.c        **** 		for (i = 0; i < CUBE_SIZE; i++)
 108:draw.c        **** 		{
 109:draw.c        **** 			cube[z][i] = 0xff;
 583               		.loc 1 109 0
 584 021a FC01      		movw r30,r24
 585 021c 63E0      		ldi r22,3
 586 021e EE0F      	1:	lsl r30
 587 0220 FF1F      		rol r31
 588 0222 6A95      		dec r22
 589 0224 01F4      		brne 1b
 590 0226 E050      		subi r30,lo8(-(cube))
 591 0228 F040      		sbci r31,hi8(-(cube))
 592 022a 8FEF      		ldi r24,lo8(-1)
 593               	.LVL39:
 594 022c 8083      		st Z,r24
 595               	.LVL40:
 596 022e 8183      		std Z+1,r24
 597               	.LVL41:
 598 0230 8283      		std Z+2,r24
 599               	.LVL42:
 600 0232 8383      		std Z+3,r24
 601               	.LVL43:
 602 0234 8483      		std Z+4,r24
 603               	.LVL44:
 604 0236 8583      		std Z+5,r24
 605               	.LVL45:
 606 0238 8683      		std Z+6,r24
 607               	.LVL46:
 608 023a 8783      		std Z+7,r24
 609               	.LVL47:
 610               	.L27:
 611 023c 0895      		ret
 612               		.cfi_endproc
 613               	.LFE10:
 615               	.global	clrplane_z
 617               	clrplane_z:
 618               	.LFB11:
 110:draw.c        **** 		}
 111:draw.c        **** 	}
 112:draw.c        **** }
 113:draw.c        **** 
 114:draw.c        **** // Clears voxels in the same manner as above
 115:draw.c        **** void clrplane_z (int z)
 116:draw.c        **** {
 619               		.loc 1 116 0
 620               		.cfi_startproc
 621               	.LVL48:
 622               	/* prologue: function */
 623               	/* frame size = 0 */
 624               	/* stack size = 0 */
 625               	.L__stack_usage = 0
 117:draw.c        **** 	int i;
 118:draw.c        **** 	if (z>=0 && z<CUBE_SIZE)
 626               		.loc 1 118 0
 627 023e 8830      		cpi r24,8
 628 0240 9105      		cpc r25,__zero_reg__
 629 0242 00F4      		brsh .L29
 119:draw.c        **** 	{
 120:draw.c        **** 		for (i=0;i<CUBE_SIZE;i++)
 121:draw.c        **** 			cube[z][i] = 0x00;
 630               		.loc 1 121 0
 631 0244 FC01      		movw r30,r24
 632 0246 73E0      		ldi r23,3
 633 0248 EE0F      	1:	lsl r30
 634 024a FF1F      		rol r31
 635 024c 7A95      		dec r23
 636 024e 01F4      		brne 1b
 637 0250 E050      		subi r30,lo8(-(cube))
 638 0252 F040      		sbci r31,hi8(-(cube))
 639 0254 1082      		st Z,__zero_reg__
 640               	.LVL49:
 641 0256 1182      		std Z+1,__zero_reg__
 642               	.LVL50:
 643 0258 1282      		std Z+2,__zero_reg__
 644               	.LVL51:
 645 025a 1382      		std Z+3,__zero_reg__
 646               	.LVL52:
 647 025c 1482      		std Z+4,__zero_reg__
 648               	.LVL53:
 649 025e 1582      		std Z+5,__zero_reg__
 650               	.LVL54:
 651 0260 1682      		std Z+6,__zero_reg__
 652               	.LVL55:
 653 0262 1782      		std Z+7,__zero_reg__
 654               	.LVL56:
 655               	.L29:
 656 0264 0895      		ret
 657               		.cfi_endproc
 658               	.LFE11:
 660               	.global	setplane_x
 662               	setplane_x:
 663               	.LFB12:
 122:draw.c        **** 	}
 123:draw.c        **** }
 124:draw.c        **** 
 125:draw.c        **** void setplane_x (int x)
 126:draw.c        **** {
 664               		.loc 1 126 0
 665               		.cfi_startproc
 666               	.LVL57:
 667               	/* prologue: function */
 668               	/* frame size = 0 */
 669               	/* stack size = 0 */
 670               	.L__stack_usage = 0
 127:draw.c        **** 	int z;
 128:draw.c        **** 	int y;
 129:draw.c        **** 	if (x>=0 && x<CUBE_SIZE)
 671               		.loc 1 129 0
 672 0266 8830      		cpi r24,8
 673 0268 9105      		cpc r25,__zero_reg__
 674 026a 00F4      		brsh .L31
 130:draw.c        **** 	{
 131:draw.c        **** 		for (z=0;z<CUBE_SIZE;z++)
 132:draw.c        **** 		{
 133:draw.c        **** 			for (y=0;y<CUBE_SIZE;y++)
 134:draw.c        **** 			{
 135:draw.c        **** 				cube[z][y] |= (1 << x);
 675               		.loc 1 135 0
 676 026c 21E0      		ldi r18,lo8(1)
 677 026e 30E0      		ldi r19,hi8(1)
 678 0270 00C0      		rjmp 2f
 679 0272 220F      	1:	lsl r18
 680 0274 331F      		rol r19
 681 0276 8A95      	2:	dec r24
 682 0278 02F4      		brpl 1b
 683 027a 722F      		mov r23,r18
 684 027c 40E0      		ldi r20,lo8(0)
 685 027e 50E0      		ldi r21,hi8(0)
 686 0280 00C0      		rjmp .L33
 687               	.LVL58:
 688               	.L34:
 689               		.loc 1 135 0 is_stmt 0 discriminator 2
 690 0282 FC01      		movw r30,r24
 691 0284 E20F      		add r30,r18
 692 0286 F31F      		adc r31,r19
 693 0288 E050      		subi r30,lo8(-(cube))
 694 028a F040      		sbci r31,hi8(-(cube))
 695 028c 6081      		ld r22,Z
 696 028e 672B      		or r22,r23
 697 0290 6083      		st Z,r22
 133:draw.c        **** 			for (y=0;y<CUBE_SIZE;y++)
 698               		.loc 1 133 0 is_stmt 1 discriminator 2
 699 0292 2F5F      		subi r18,lo8(-(1))
 700 0294 3F4F      		sbci r19,hi8(-(1))
 701               	.LVL59:
 702 0296 2830      		cpi r18,8
 703 0298 3105      		cpc r19,__zero_reg__
 704 029a 01F4      		brne .L34
 131:draw.c        **** 		for (z=0;z<CUBE_SIZE;z++)
 705               		.loc 1 131 0
 706 029c 4F5F      		subi r20,lo8(-(1))
 707 029e 5F4F      		sbci r21,hi8(-(1))
 708               	.LVL60:
 709 02a0 4830      		cpi r20,8
 710 02a2 5105      		cpc r21,__zero_reg__
 711 02a4 01F0      		breq .L31
 712               	.LVL61:
 713               	.L33:
 126:draw.c        **** {
 714               		.loc 1 126 0 discriminator 1
 715 02a6 20E0      		ldi r18,lo8(0)
 716 02a8 30E0      		ldi r19,hi8(0)
 717               		.loc 1 135 0 discriminator 1
 718 02aa CA01      		movw r24,r20
 719 02ac E3E0      		ldi r30,3
 720 02ae 880F      	1:	lsl r24
 721 02b0 991F      		rol r25
 722 02b2 EA95      		dec r30
 723 02b4 01F4      		brne 1b
 724 02b6 00C0      		rjmp .L34
 725               	.LVL62:
 726               	.L31:
 727 02b8 0895      		ret
 728               		.cfi_endproc
 729               	.LFE12:
 731               	.global	clrplane_x
 733               	clrplane_x:
 734               	.LFB13:
 136:draw.c        **** 			}
 137:draw.c        **** 		}
 138:draw.c        **** 	}
 139:draw.c        **** }
 140:draw.c        **** 
 141:draw.c        **** void clrplane_x (int x)
 142:draw.c        **** {
 735               		.loc 1 142 0
 736               		.cfi_startproc
 737               	.LVL63:
 738               	/* prologue: function */
 739               	/* frame size = 0 */
 740               	/* stack size = 0 */
 741               	.L__stack_usage = 0
 143:draw.c        **** 	int z;
 144:draw.c        **** 	int y;
 145:draw.c        **** 	if (x>=0 && x<CUBE_SIZE)
 742               		.loc 1 145 0
 743 02ba 8830      		cpi r24,8
 744 02bc 9105      		cpc r25,__zero_reg__
 745 02be 00F4      		brsh .L36
 146:draw.c        **** 	{
 147:draw.c        **** 		for (z=0;z<CUBE_SIZE;z++)
 148:draw.c        **** 		{
 149:draw.c        **** 			for (y=0;y<CUBE_SIZE;y++)
 150:draw.c        **** 			{
 151:draw.c        **** 				cube[z][y] &= ~(1 << x);
 746               		.loc 1 151 0
 747 02c0 21E0      		ldi r18,lo8(1)
 748 02c2 30E0      		ldi r19,hi8(1)
 749 02c4 00C0      		rjmp 2f
 750 02c6 220F      	1:	lsl r18
 751 02c8 331F      		rol r19
 752 02ca 8A95      	2:	dec r24
 753 02cc 02F4      		brpl 1b
 754 02ce 722F      		mov r23,r18
 755 02d0 7095      		com r23
 756 02d2 40E0      		ldi r20,lo8(0)
 757 02d4 50E0      		ldi r21,hi8(0)
 758 02d6 00C0      		rjmp .L38
 759               	.LVL64:
 760               	.L39:
 761               		.loc 1 151 0 is_stmt 0 discriminator 2
 762 02d8 FC01      		movw r30,r24
 763 02da E20F      		add r30,r18
 764 02dc F31F      		adc r31,r19
 765 02de E050      		subi r30,lo8(-(cube))
 766 02e0 F040      		sbci r31,hi8(-(cube))
 767 02e2 6081      		ld r22,Z
 768 02e4 6723      		and r22,r23
 769 02e6 6083      		st Z,r22
 149:draw.c        **** 			for (y=0;y<CUBE_SIZE;y++)
 770               		.loc 1 149 0 is_stmt 1 discriminator 2
 771 02e8 2F5F      		subi r18,lo8(-(1))
 772 02ea 3F4F      		sbci r19,hi8(-(1))
 773               	.LVL65:
 774 02ec 2830      		cpi r18,8
 775 02ee 3105      		cpc r19,__zero_reg__
 776 02f0 01F4      		brne .L39
 147:draw.c        **** 		for (z=0;z<CUBE_SIZE;z++)
 777               		.loc 1 147 0
 778 02f2 4F5F      		subi r20,lo8(-(1))
 779 02f4 5F4F      		sbci r21,hi8(-(1))
 780               	.LVL66:
 781 02f6 4830      		cpi r20,8
 782 02f8 5105      		cpc r21,__zero_reg__
 783 02fa 01F0      		breq .L36
 784               	.LVL67:
 785               	.L38:
 142:draw.c        **** {
 786               		.loc 1 142 0 discriminator 1
 787 02fc 20E0      		ldi r18,lo8(0)
 788 02fe 30E0      		ldi r19,hi8(0)
 789               		.loc 1 151 0 discriminator 1
 790 0300 CA01      		movw r24,r20
 791 0302 F3E0      		ldi r31,3
 792 0304 880F      	1:	lsl r24
 793 0306 991F      		rol r25
 794 0308 FA95      		dec r31
 795 030a 01F4      		brne 1b
 796 030c 00C0      		rjmp .L39
 797               	.LVL68:
 798               	.L36:
 799 030e 0895      		ret
 800               		.cfi_endproc
 801               	.LFE13:
 803               	.global	setplane_y
 805               	setplane_y:
 806               	.LFB14:
 152:draw.c        **** 			}
 153:draw.c        **** 		}
 154:draw.c        **** 	}
 155:draw.c        **** }
 156:draw.c        **** 
 157:draw.c        **** void setplane_y (int y)
 158:draw.c        **** {
 807               		.loc 1 158 0
 808               		.cfi_startproc
 809               	.LVL69:
 810               	/* prologue: function */
 811               	/* frame size = 0 */
 812               	/* stack size = 0 */
 813               	.L__stack_usage = 0
 159:draw.c        **** 	int z;
 160:draw.c        **** 	if (y>=0 && y<CUBE_SIZE)
 814               		.loc 1 160 0
 815 0310 8830      		cpi r24,8
 816 0312 9105      		cpc r25,__zero_reg__
 817 0314 00F4      		brsh .L41
 161:draw.c        **** 	{
 162:draw.c        **** 		for (z=0;z<CUBE_SIZE;z++)
 163:draw.c        **** 			cube[z][y] = 0xff;
 818               		.loc 1 163 0
 819 0316 FC01      		movw r30,r24
 820 0318 E050      		subi r30,lo8(-(cube))
 821 031a F040      		sbci r31,hi8(-(cube))
 822 031c 8FEF      		ldi r24,lo8(-1)
 823               	.LVL70:
 824 031e 8083      		st Z,r24
 825               	.LVL71:
 826 0320 8087      		std Z+8,r24
 827               	.LVL72:
 828 0322 808B      		std Z+16,r24
 829               	.LVL73:
 830 0324 808F      		std Z+24,r24
 831               	.LVL74:
 832 0326 80A3      		std Z+32,r24
 833               	.LVL75:
 834 0328 80A7      		std Z+40,r24
 835               	.LVL76:
 836 032a 80AB      		std Z+48,r24
 837               	.LVL77:
 838 032c 80AF      		std Z+56,r24
 839               	.LVL78:
 840               	.L41:
 841 032e 0895      		ret
 842               		.cfi_endproc
 843               	.LFE14:
 845               	.global	clrplane_y
 847               	clrplane_y:
 848               	.LFB15:
 164:draw.c        **** 	} 
 165:draw.c        **** }
 166:draw.c        **** 
 167:draw.c        **** void clrplane_y (int y)
 168:draw.c        **** {
 849               		.loc 1 168 0
 850               		.cfi_startproc
 851               	.LVL79:
 852               	/* prologue: function */
 853               	/* frame size = 0 */
 854               	/* stack size = 0 */
 855               	.L__stack_usage = 0
 169:draw.c        **** 	int z;
 170:draw.c        **** 	if (y>=0 && y<CUBE_SIZE)
 856               		.loc 1 170 0
 857 0330 8830      		cpi r24,8
 858 0332 9105      		cpc r25,__zero_reg__
 859 0334 00F4      		brsh .L43
 171:draw.c        **** 	{
 172:draw.c        **** 		for (z=0;z<CUBE_SIZE;z++)
 173:draw.c        **** 			cube[z][y] = 0x00; 
 860               		.loc 1 173 0
 861 0336 FC01      		movw r30,r24
 862 0338 E050      		subi r30,lo8(-(cube))
 863 033a F040      		sbci r31,hi8(-(cube))
 864 033c 1082      		st Z,__zero_reg__
 865               	.LVL80:
 866 033e 1086      		std Z+8,__zero_reg__
 867               	.LVL81:
 868 0340 108A      		std Z+16,__zero_reg__
 869               	.LVL82:
 870 0342 108E      		std Z+24,__zero_reg__
 871               	.LVL83:
 872 0344 10A2      		std Z+32,__zero_reg__
 873               	.LVL84:
 874 0346 10A6      		std Z+40,__zero_reg__
 875               	.LVL85:
 876 0348 10AA      		std Z+48,__zero_reg__
 877               	.LVL86:
 878 034a 10AE      		std Z+56,__zero_reg__
 879               	.LVL87:
 880               	.L43:
 881 034c 0895      		ret
 882               		.cfi_endproc
 883               	.LFE15:
 885               	.global	setplane
 887               	setplane:
 888               	.LFB16:
 174:draw.c        **** 	}
 175:draw.c        **** }
 176:draw.c        **** 
 177:draw.c        **** void setplane (char axis, unsigned char i)
 178:draw.c        **** {
 889               		.loc 1 178 0
 890               		.cfi_startproc
 891               	.LVL88:
 892               	/* prologue: function */
 893               	/* frame size = 0 */
 894               	/* stack size = 0 */
 895               	.L__stack_usage = 0
 896 034e 982F      		mov r25,r24
 897 0350 862F      		mov r24,r22
 898               	.LVL89:
 179:draw.c        ****     switch (axis)
 899               		.loc 1 179 0
 900 0352 9937      		cpi r25,lo8(121)
 901 0354 01F0      		breq .L48
 902 0356 9A37      		cpi r25,lo8(122)
 903 0358 01F0      		breq .L49
 904 035a 9837      		cpi r25,lo8(120)
 905 035c 01F4      		brne .L45
 180:draw.c        ****     {
 181:draw.c        ****         case AXIS_X:
 182:draw.c        ****             setplane_x(i);
 906               		.loc 1 182 0
 907 035e 90E0      		ldi r25,lo8(0)
 908               	.LVL90:
 909 0360 0E94 0000 		call setplane_x
 910               	.LVL91:
 183:draw.c        ****             break;
 911               		.loc 1 183 0
 912 0364 0895      		ret
 913               	.LVL92:
 914               	.L48:
 184:draw.c        ****         
 185:draw.c        ****        case AXIS_Y:
 186:draw.c        ****             setplane_y(i);
 915               		.loc 1 186 0
 916 0366 90E0      		ldi r25,lo8(0)
 917               	.LVL93:
 918 0368 0E94 0000 		call setplane_y
 919               	.LVL94:
 187:draw.c        ****             break;
 920               		.loc 1 187 0
 921 036c 0895      		ret
 922               	.LVL95:
 923               	.L49:
 188:draw.c        **** 
 189:draw.c        ****        case AXIS_Z:
 190:draw.c        ****             setplane_z(i);
 924               		.loc 1 190 0
 925 036e 90E0      		ldi r25,lo8(0)
 926               	.LVL96:
 927 0370 0E94 0000 		call setplane_z
 928               	.LVL97:
 929               	.L45:
 930 0374 0895      		ret
 931               		.cfi_endproc
 932               	.LFE16:
 934               	.global	clrplane
 936               	clrplane:
 937               	.LFB17:
 191:draw.c        ****             break;
 192:draw.c        ****     }
 193:draw.c        **** }
 194:draw.c        **** 
 195:draw.c        **** void clrplane (char axis, unsigned char i)
 196:draw.c        **** {
 938               		.loc 1 196 0
 939               		.cfi_startproc
 940               	.LVL98:
 941               	/* prologue: function */
 942               	/* frame size = 0 */
 943               	/* stack size = 0 */
 944               	.L__stack_usage = 0
 945 0376 982F      		mov r25,r24
 946 0378 862F      		mov r24,r22
 947               	.LVL99:
 197:draw.c        ****     switch (axis)
 948               		.loc 1 197 0
 949 037a 9937      		cpi r25,lo8(121)
 950 037c 01F0      		breq .L53
 951 037e 9A37      		cpi r25,lo8(122)
 952 0380 01F0      		breq .L54
 953 0382 9837      		cpi r25,lo8(120)
 954 0384 01F4      		brne .L50
 198:draw.c        ****     {
 199:draw.c        ****         case AXIS_X:
 200:draw.c        ****             clrplane_x(i);
 955               		.loc 1 200 0
 956 0386 90E0      		ldi r25,lo8(0)
 957               	.LVL100:
 958 0388 0E94 0000 		call clrplane_x
 959               	.LVL101:
 201:draw.c        ****             break;
 960               		.loc 1 201 0
 961 038c 0895      		ret
 962               	.LVL102:
 963               	.L53:
 202:draw.c        ****         
 203:draw.c        ****        case AXIS_Y:
 204:draw.c        ****             clrplane_y(i);
 964               		.loc 1 204 0
 965 038e 90E0      		ldi r25,lo8(0)
 966               	.LVL103:
 967 0390 0E94 0000 		call clrplane_y
 968               	.LVL104:
 205:draw.c        ****             break;
 969               		.loc 1 205 0
 970 0394 0895      		ret
 971               	.LVL105:
 972               	.L54:
 206:draw.c        **** 
 207:draw.c        ****        case AXIS_Z:
 208:draw.c        ****             clrplane_z(i);
 973               		.loc 1 208 0
 974 0396 90E0      		ldi r25,lo8(0)
 975               	.LVL106:
 976 0398 0E94 0000 		call clrplane_z
 977               	.LVL107:
 978               	.L50:
 979 039c 0895      		ret
 980               		.cfi_endproc
 981               	.LFE17:
 983               	.global	fill
 985               	fill:
 986               	.LFB18:
 209:draw.c        ****             break;
 210:draw.c        ****     }
 211:draw.c        **** }
 212:draw.c        **** 
 213:draw.c        **** // Fill a value into all 64 byts of the cube buffer
 214:draw.c        **** // Mostly used for clearing. fill(0x00)
 215:draw.c        **** // or setting all on. fill(0xff)
 216:draw.c        **** void fill (unsigned char pattern)
 217:draw.c        **** {
 987               		.loc 1 217 0
 988               		.cfi_startproc
 989               	.LVL108:
 990               	/* prologue: function */
 991               	/* frame size = 0 */
 992               	/* stack size = 0 */
 993               	.L__stack_usage = 0
 218:draw.c        **** 	int z;
 219:draw.c        **** 	int y;
 220:draw.c        **** 	for (z=0;z<CUBE_SIZE;z++)
 994               		.loc 1 220 0
 995 039e 20E0      		ldi r18,lo8(0)
 996 03a0 30E0      		ldi r19,hi8(0)
 997               	.LVL109:
 998               	.L56:
 221:draw.c        **** 	{
 222:draw.c        **** 		for (y=0;y<CUBE_SIZE;y++)
 223:draw.c        **** 		{
 224:draw.c        **** 			cube[z][y] = pattern;
 999               		.loc 1 224 0 discriminator 1
 1000 03a2 F901      		movw r30,r18
 1001 03a4 A3E0      		ldi r26,3
 1002 03a6 EE0F      	1:	lsl r30
 1003 03a8 FF1F      		rol r31
 1004 03aa AA95      		dec r26
 1005 03ac 01F4      		brne 1b
 1006 03ae E050      		subi r30,lo8(-(cube))
 1007 03b0 F040      		sbci r31,hi8(-(cube))
 1008 03b2 8083      		st Z,r24
 1009               	.LVL110:
 1010 03b4 8183      		std Z+1,r24
 1011               	.LVL111:
 1012 03b6 8283      		std Z+2,r24
 1013               	.LVL112:
 1014 03b8 8383      		std Z+3,r24
 1015               	.LVL113:
 1016 03ba 8483      		std Z+4,r24
 1017               	.LVL114:
 1018 03bc 8583      		std Z+5,r24
 1019               	.LVL115:
 1020 03be 8683      		std Z+6,r24
 1021               	.LVL116:
 1022 03c0 8783      		std Z+7,r24
 1023               	.LVL117:
 220:draw.c        **** 	for (z=0;z<CUBE_SIZE;z++)
 1024               		.loc 1 220 0 discriminator 1
 1025 03c2 2F5F      		subi r18,lo8(-(1))
 1026 03c4 3F4F      		sbci r19,hi8(-(1))
 1027               	.LVL118:
 1028 03c6 2830      		cpi r18,8
 1029 03c8 3105      		cpc r19,__zero_reg__
 1030 03ca 01F4      		brne .L56
 1031               	/* epilogue start */
 225:draw.c        **** 		}
 226:draw.c        **** 	}
 227:draw.c        **** }
 1032               		.loc 1 227 0
 1033 03cc 0895      		ret
 1034               		.cfi_endproc
 1035               	.LFE18:
 1037               	.global	tmpfill
 1039               	tmpfill:
 1040               	.LFB19:
 228:draw.c        **** 
 229:draw.c        **** void tmpfill (unsigned char pattern)
 230:draw.c        **** {
 1041               		.loc 1 230 0
 1042               		.cfi_startproc
 1043               	.LVL119:
 1044               	/* prologue: function */
 1045               	/* frame size = 0 */
 1046               	/* stack size = 0 */
 1047               	.L__stack_usage = 0
 231:draw.c        **** 	int z;
 232:draw.c        **** 	int y;
 233:draw.c        **** 	for (z=0;z<CUBE_SIZE;z++)
 1048               		.loc 1 233 0
 1049 03ce 20E0      		ldi r18,lo8(0)
 1050 03d0 30E0      		ldi r19,hi8(0)
 1051               	.LVL120:
 1052               	.L59:
 234:draw.c        **** 	{
 235:draw.c        **** 		for (y=0;y<CUBE_SIZE;y++)
 236:draw.c        **** 		{
 237:draw.c        **** 			fb[z][y] = pattern;
 1053               		.loc 1 237 0 discriminator 1
 1054 03d2 F901      		movw r30,r18
 1055 03d4 B3E0      		ldi r27,3
 1056 03d6 EE0F      	1:	lsl r30
 1057 03d8 FF1F      		rol r31
 1058 03da BA95      		dec r27
 1059 03dc 01F4      		brne 1b
 1060 03de E050      		subi r30,lo8(-(fb))
 1061 03e0 F040      		sbci r31,hi8(-(fb))
 1062 03e2 8083      		st Z,r24
 1063               	.LVL121:
 1064 03e4 8183      		std Z+1,r24
 1065               	.LVL122:
 1066 03e6 8283      		std Z+2,r24
 1067               	.LVL123:
 1068 03e8 8383      		std Z+3,r24
 1069               	.LVL124:
 1070 03ea 8483      		std Z+4,r24
 1071               	.LVL125:
 1072 03ec 8583      		std Z+5,r24
 1073               	.LVL126:
 1074 03ee 8683      		std Z+6,r24
 1075               	.LVL127:
 1076 03f0 8783      		std Z+7,r24
 1077               	.LVL128:
 233:draw.c        **** 	for (z=0;z<CUBE_SIZE;z++)
 1078               		.loc 1 233 0 discriminator 1
 1079 03f2 2F5F      		subi r18,lo8(-(1))
 1080 03f4 3F4F      		sbci r19,hi8(-(1))
 1081               	.LVL129:
 1082 03f6 2830      		cpi r18,8
 1083 03f8 3105      		cpc r19,__zero_reg__
 1084 03fa 01F4      		brne .L59
 1085               	/* epilogue start */
 238:draw.c        **** 		}
 239:draw.c        **** 	}
 240:draw.c        **** }
 1086               		.loc 1 240 0
 1087 03fc 0895      		ret
 1088               		.cfi_endproc
 1089               	.LFE19:
 1091               	.global	byteline
 1093               	byteline:
 1094               	.LFB23:
 241:draw.c        **** 
 242:draw.c        **** // Draw a box with all walls drawn and all voxels inside set
 243:draw.c        **** void box_filled(int x1, int y1, int z1, int x2, int y2, int z2)
 244:draw.c        **** {
 245:draw.c        **** 	int iy;
 246:draw.c        **** 	int iz;
 247:draw.c        **** 
 248:draw.c        **** 	argorder(x1, x2, &x1, &x2);
 249:draw.c        **** 	argorder(y1, y2, &y1, &y2);
 250:draw.c        **** 	argorder(z1, z2, &z1, &z2);
 251:draw.c        **** 
 252:draw.c        **** 	for (iz=z1;iz<=z2;iz++)
 253:draw.c        **** 	{
 254:draw.c        **** 		for (iy=y1;iy<=y2;iy++)
 255:draw.c        **** 		{
 256:draw.c        **** 			cube[iz][iy] |= byteline(x1,x2);
 257:draw.c        **** 		}
 258:draw.c        **** 	}
 259:draw.c        **** 
 260:draw.c        **** }
 261:draw.c        **** 
 262:draw.c        **** // Darw a hollow box with side walls.
 263:draw.c        **** void box_walls(int x1, int y1, int z1, int x2, int y2, int z2)
 264:draw.c        **** {
 265:draw.c        **** 	int iy;
 266:draw.c        **** 	int iz;
 267:draw.c        **** 	
 268:draw.c        **** 	argorder(x1, x2, &x1, &x2);
 269:draw.c        **** 	argorder(y1, y2, &y1, &y2);
 270:draw.c        **** 	argorder(z1, z2, &z1, &z2);
 271:draw.c        **** 
 272:draw.c        **** 	for (iz=z1;iz<=z2;iz++)
 273:draw.c        **** 	{
 274:draw.c        **** 		for (iy=y1;iy<=y2;iy++)
 275:draw.c        **** 		{	
 276:draw.c        **** 			if (iy == y1 || iy == y2 || iz == z1 || iz == z2)
 277:draw.c        **** 			{
 278:draw.c        **** 				cube[iz][iy] = byteline(x1,x2);
 279:draw.c        **** 			} else
 280:draw.c        **** 			{
 281:draw.c        **** 				cube[iz][iy] |= ((0x01 << x1) | (0x01 << x2));
 282:draw.c        **** 			}
 283:draw.c        **** 		}
 284:draw.c        **** 	}
 285:draw.c        **** 
 286:draw.c        **** }
 287:draw.c        **** 
 288:draw.c        **** // Draw a wireframe box. This only draws the corners and edges,
 289:draw.c        **** // no walls.
 290:draw.c        **** void box_wireframe(int x1, int y1, int z1, int x2, int y2, int z2)
 291:draw.c        **** {
 292:draw.c        **** 	int iy;
 293:draw.c        **** 	int iz;
 294:draw.c        **** 
 295:draw.c        **** 	argorder(x1, x2, &x1, &x2);
 296:draw.c        **** 	argorder(y1, y2, &y1, &y2);
 297:draw.c        **** 	argorder(z1, z2, &z1, &z2);
 298:draw.c        **** 
 299:draw.c        **** 	// Lines along X axis
 300:draw.c        **** 	cube[z1][y1] = byteline(x1,x2);
 301:draw.c        **** 	cube[z1][y2] = byteline(x1,x2);
 302:draw.c        **** 	cube[z2][y1] = byteline(x1,x2);
 303:draw.c        **** 	cube[z2][y2] = byteline(x1,x2);
 304:draw.c        **** 
 305:draw.c        **** 	// Lines along Y axis
 306:draw.c        **** 	for (iy=y1;iy<=y2;iy++)
 307:draw.c        **** 	{
 308:draw.c        **** 		setvoxel(x1,iy,z1);
 309:draw.c        **** 		setvoxel(x1,iy,z2);
 310:draw.c        **** 		setvoxel(x2,iy,z1);
 311:draw.c        **** 		setvoxel(x2,iy,z2);
 312:draw.c        **** 	}
 313:draw.c        **** 
 314:draw.c        **** 	// Lines along Z axis
 315:draw.c        **** 	for (iz=z1;iz<=z2;iz++)
 316:draw.c        **** 	{
 317:draw.c        **** 		setvoxel(x1,y1,iz);
 318:draw.c        **** 		setvoxel(x1,y2,iz);
 319:draw.c        **** 		setvoxel(x2,y1,iz);
 320:draw.c        **** 		setvoxel(x2,y2,iz);
 321:draw.c        **** 	}
 322:draw.c        **** 
 323:draw.c        **** }
 324:draw.c        **** 
 325:draw.c        **** // Returns a byte with a row of 1's drawn in it.
 326:draw.c        **** // byteline(2,5) gives 0b00111100
 327:draw.c        **** char byteline (int start, int end)
 328:draw.c        **** {
 1095               		.loc 1 328 0
 1096               		.cfi_startproc
 1097               	.LVL130:
 1098               	/* prologue: function */
 1099               	/* frame size = 0 */
 1100               	/* stack size = 0 */
 1101               	.L__stack_usage = 0
 329:draw.c        **** 	return ((0xff<<start) & ~(0xff<<(end+1)));
 1102               		.loc 1 329 0
 1103 03fe 6F5F      		subi r22,lo8(-(1))
 1104 0400 7F4F      		sbci r23,hi8(-(1))
 1105               	.LVL131:
 1106 0402 2FEF      		ldi r18,lo8(255)
 1107 0404 30E0      		ldi r19,hi8(255)
 1108 0406 A901      		movw r20,r18
 1109 0408 00C0      		rjmp 2f
 1110 040a 440F      	1:	lsl r20
 1111 040c 551F      		rol r21
 1112 040e 6A95      	2:	dec r22
 1113 0410 02F4      		brpl 1b
 1114 0412 BA01      		movw r22,r20
 1115               	.LVL132:
 1116 0414 6095      		com r22
 1117 0416 00C0      		rjmp 2f
 1118 0418 220F      	1:	lsl r18
 1119 041a 331F      		rol r19
 1120 041c 8A95      	2:	dec r24
 1121 041e 02F4      		brpl 1b
 330:draw.c        **** }
 1122               		.loc 1 330 0
 1123 0420 862F      		mov r24,r22
 1124               	.LVL133:
 1125 0422 8223      		and r24,r18
 1126               	/* epilogue start */
 1127 0424 0895      		ret
 1128               		.cfi_endproc
 1129               	.LFE23:
 1131               	.global	box_wireframe
 1133               	box_wireframe:
 1134               	.LFB22:
 291:draw.c        **** {
 1135               		.loc 1 291 0
 1136               		.cfi_startproc
 1137               	.LVL134:
 1138 0426 6F92      		push r6
 1139               	.LCFI30:
 1140               		.cfi_def_cfa_offset 3
 1141               		.cfi_offset 6, -2
 1142 0428 7F92      		push r7
 1143               	.LCFI31:
 1144               		.cfi_def_cfa_offset 4
 1145               		.cfi_offset 7, -3
 1146 042a 8F92      		push r8
 1147               	.LCFI32:
 1148               		.cfi_def_cfa_offset 5
 1149               		.cfi_offset 8, -4
 1150 042c 9F92      		push r9
 1151               	.LCFI33:
 1152               		.cfi_def_cfa_offset 6
 1153               		.cfi_offset 9, -5
 1154 042e AF92      		push r10
 1155               	.LCFI34:
 1156               		.cfi_def_cfa_offset 7
 1157               		.cfi_offset 10, -6
 1158 0430 BF92      		push r11
 1159               	.LCFI35:
 1160               		.cfi_def_cfa_offset 8
 1161               		.cfi_offset 11, -7
 1162 0432 CF92      		push r12
 1163               	.LCFI36:
 1164               		.cfi_def_cfa_offset 9
 1165               		.cfi_offset 12, -8
 1166 0434 DF92      		push r13
 1167               	.LCFI37:
 1168               		.cfi_def_cfa_offset 10
 1169               		.cfi_offset 13, -9
 1170 0436 EF92      		push r14
 1171               	.LCFI38:
 1172               		.cfi_def_cfa_offset 11
 1173               		.cfi_offset 14, -10
 1174 0438 FF92      		push r15
 1175               	.LCFI39:
 1176               		.cfi_def_cfa_offset 12
 1177               		.cfi_offset 15, -11
 1178 043a 0F93      		push r16
 1179               	.LCFI40:
 1180               		.cfi_def_cfa_offset 13
 1181               		.cfi_offset 16, -12
 1182 043c 1F93      		push r17
 1183               	.LCFI41:
 1184               		.cfi_def_cfa_offset 14
 1185               		.cfi_offset 17, -13
 1186 043e CF93      		push r28
 1187               	.LCFI42:
 1188               		.cfi_def_cfa_offset 15
 1189               		.cfi_offset 28, -14
 1190 0440 DF93      		push r29
 1191               	.LCFI43:
 1192               		.cfi_def_cfa_offset 16
 1193               		.cfi_offset 29, -15
 1194               	/* prologue: function */
 1195               	/* frame size = 0 */
 1196               	/* stack size = 14 */
 1197               	.L__stack_usage = 14
 1198 0442 4C01      		movw r8,r24
 1199 0444 5B01      		movw r10,r22
 1200 0446 3A01      		movw r6,r20
 1201 0448 6901      		movw r12,r18
 1202               	.LVL135:
 1203               	.LBB20:
 1204               	.LBB21:
  89:draw.c        **** 	if (ix1 > ix2)
 1205               		.loc 1 89 0
 1206 044a 2817      		cp r18,r24
 1207 044c 3907      		cpc r19,r25
 1208 044e 04F4      		brge .L63
 1209               	.LVL136:
 1210 0450 982F      		mov r25,r24
 1211 0452 892D      		mov r24,r9
 1212 0454 4901      		movw r8,r18
 1213               	.LVL137:
 1214 0456 C92E      		mov r12,r25
 1215               	.LVL138:
 1216 0458 D82E      		mov r13,r24
 1217               	.LVL139:
 1218               	.L63:
 1219               	.LBE21:
 1220               	.LBE20:
 1221               	.LBB22:
 1222               	.LBB23:
 1223 045a 0A15      		cp r16,r10
 1224 045c 1B05      		cpc r17,r11
 1225 045e 04F4      		brge .L64
 1226               	.LVL140:
 1227 0460 9A2D      		mov r25,r10
 1228 0462 8B2D      		mov r24,r11
 1229 0464 5801      		movw r10,r16
 1230               	.LVL141:
 1231 0466 092F      		mov r16,r25
 1232               	.LVL142:
 1233 0468 182F      		mov r17,r24
 1234               	.LVL143:
 1235               	.L64:
 1236               	.LBE23:
 1237               	.LBE22:
 1238               	.LBB24:
 1239               	.LBB25:
 1240 046a E614      		cp r14,r6
 1241 046c F704      		cpc r15,r7
 1242 046e 04F4      		brge .L65
 1243               	.LVL144:
 1244 0470 962D      		mov r25,r6
 1245 0472 872D      		mov r24,r7
 1246 0474 3701      		movw r6,r14
 1247               	.LVL145:
 1248 0476 E92E      		mov r14,r25
 1249               	.LVL146:
 1250 0478 F82E      		mov r15,r24
 1251               	.LVL147:
 1252               	.L65:
 1253               	.LBE25:
 1254               	.LBE24:
 300:draw.c        **** 	cube[z1][y1] = byteline(x1,x2);
 1255               		.loc 1 300 0
 1256 047a C401      		movw r24,r8
 1257 047c B601      		movw r22,r12
 1258 047e 0E94 0000 		call byteline
 1259 0482 282F      		mov r18,r24
 1260 0484 C301      		movw r24,r6
 1261 0486 C3E0      		ldi r28,3
 1262 0488 880F      	1:	lsl r24
 1263 048a 991F      		rol r25
 1264 048c CA95      		dec r28
 1265 048e 01F4      		brne 1b
 1266 0490 FC01      		movw r30,r24
 1267 0492 EA0D      		add r30,r10
 1268 0494 FB1D      		adc r31,r11
 1269 0496 E050      		subi r30,lo8(-(cube))
 1270 0498 F040      		sbci r31,hi8(-(cube))
 1271 049a 2083      		st Z,r18
 301:draw.c        **** 	cube[z1][y2] = byteline(x1,x2);
 1272               		.loc 1 301 0
 1273 049c FC01      		movw r30,r24
 1274 049e E00F      		add r30,r16
 1275 04a0 F11F      		adc r31,r17
 1276 04a2 E050      		subi r30,lo8(-(cube))
 1277 04a4 F040      		sbci r31,hi8(-(cube))
 1278 04a6 2083      		st Z,r18
 302:draw.c        **** 	cube[z2][y1] = byteline(x1,x2);
 1279               		.loc 1 302 0
 1280 04a8 C701      		movw r24,r14
 1281 04aa D3E0      		ldi r29,3
 1282 04ac 880F      	1:	lsl r24
 1283 04ae 991F      		rol r25
 1284 04b0 DA95      		dec r29
 1285 04b2 01F4      		brne 1b
 1286 04b4 FC01      		movw r30,r24
 1287 04b6 EA0D      		add r30,r10
 1288 04b8 FB1D      		adc r31,r11
 1289 04ba E050      		subi r30,lo8(-(cube))
 1290 04bc F040      		sbci r31,hi8(-(cube))
 1291 04be 2083      		st Z,r18
 303:draw.c        **** 	cube[z2][y2] = byteline(x1,x2);
 1292               		.loc 1 303 0
 1293 04c0 FC01      		movw r30,r24
 1294 04c2 E00F      		add r30,r16
 1295 04c4 F11F      		adc r31,r17
 1296 04c6 E050      		subi r30,lo8(-(cube))
 1297 04c8 F040      		sbci r31,hi8(-(cube))
 1298 04ca 2083      		st Z,r18
 1299               	.LVL148:
 306:draw.c        **** 	for (iy=y1;iy<=y2;iy++)
 1300               		.loc 1 306 0
 1301 04cc E501      		movw r28,r10
 1302 04ce 00C0      		rjmp .L66
 1303               	.LVL149:
 1304               	.L67:
 308:draw.c        **** 		setvoxel(x1,iy,z1);
 1305               		.loc 1 308 0 discriminator 2
 1306 04d0 C401      		movw r24,r8
 1307 04d2 BE01      		movw r22,r28
 1308 04d4 A301      		movw r20,r6
 1309 04d6 0E94 0000 		call setvoxel
 309:draw.c        **** 		setvoxel(x1,iy,z2);
 1310               		.loc 1 309 0 discriminator 2
 1311 04da C401      		movw r24,r8
 1312 04dc BE01      		movw r22,r28
 1313 04de A701      		movw r20,r14
 1314 04e0 0E94 0000 		call setvoxel
 310:draw.c        **** 		setvoxel(x2,iy,z1);
 1315               		.loc 1 310 0 discriminator 2
 1316 04e4 C601      		movw r24,r12
 1317 04e6 BE01      		movw r22,r28
 1318 04e8 A301      		movw r20,r6
 1319 04ea 0E94 0000 		call setvoxel
 311:draw.c        **** 		setvoxel(x2,iy,z2);
 1320               		.loc 1 311 0 discriminator 2
 1321 04ee C601      		movw r24,r12
 1322 04f0 BE01      		movw r22,r28
 1323 04f2 A701      		movw r20,r14
 1324 04f4 0E94 0000 		call setvoxel
 306:draw.c        **** 	for (iy=y1;iy<=y2;iy++)
 1325               		.loc 1 306 0 discriminator 2
 1326 04f8 2196      		adiw r28,1
 1327               	.LVL150:
 1328               	.L66:
 306:draw.c        **** 	for (iy=y1;iy<=y2;iy++)
 1329               		.loc 1 306 0 is_stmt 0 discriminator 1
 1330 04fa 0C17      		cp r16,r28
 1331 04fc 1D07      		cpc r17,r29
 1332 04fe 04F4      		brge .L67
 1333 0500 E301      		movw r28,r6
 1334               	.LVL151:
 1335 0502 00C0      		rjmp .L68
 1336               	.LVL152:
 1337               	.L69:
 317:draw.c        **** 		setvoxel(x1,y1,iz);
 1338               		.loc 1 317 0 is_stmt 1 discriminator 2
 1339 0504 C401      		movw r24,r8
 1340 0506 B501      		movw r22,r10
 1341 0508 AE01      		movw r20,r28
 1342 050a 0E94 0000 		call setvoxel
 318:draw.c        **** 		setvoxel(x1,y2,iz);
 1343               		.loc 1 318 0 discriminator 2
 1344 050e C401      		movw r24,r8
 1345 0510 B801      		movw r22,r16
 1346 0512 AE01      		movw r20,r28
 1347 0514 0E94 0000 		call setvoxel
 319:draw.c        **** 		setvoxel(x2,y1,iz);
 1348               		.loc 1 319 0 discriminator 2
 1349 0518 C601      		movw r24,r12
 1350 051a B501      		movw r22,r10
 1351 051c AE01      		movw r20,r28
 1352 051e 0E94 0000 		call setvoxel
 320:draw.c        **** 		setvoxel(x2,y2,iz);
 1353               		.loc 1 320 0 discriminator 2
 1354 0522 C601      		movw r24,r12
 1355 0524 B801      		movw r22,r16
 1356 0526 AE01      		movw r20,r28
 1357 0528 0E94 0000 		call setvoxel
 315:draw.c        **** 	for (iz=z1;iz<=z2;iz++)
 1358               		.loc 1 315 0 discriminator 2
 1359 052c 2196      		adiw r28,1
 1360               	.LVL153:
 1361               	.L68:
 315:draw.c        **** 	for (iz=z1;iz<=z2;iz++)
 1362               		.loc 1 315 0 is_stmt 0 discriminator 1
 1363 052e EC16      		cp r14,r28
 1364 0530 FD06      		cpc r15,r29
 1365 0532 04F4      		brge .L69
 1366               	/* epilogue start */
 323:draw.c        **** }
 1367               		.loc 1 323 0 is_stmt 1
 1368 0534 DF91      		pop r29
 1369 0536 CF91      		pop r28
 1370               	.LVL154:
 1371 0538 1F91      		pop r17
 1372 053a 0F91      		pop r16
 1373               	.LVL155:
 1374 053c FF90      		pop r15
 1375 053e EF90      		pop r14
 1376               	.LVL156:
 1377 0540 DF90      		pop r13
 1378 0542 CF90      		pop r12
 1379               	.LVL157:
 1380 0544 BF90      		pop r11
 1381 0546 AF90      		pop r10
 1382               	.LVL158:
 1383 0548 9F90      		pop r9
 1384 054a 8F90      		pop r8
 1385               	.LVL159:
 1386 054c 7F90      		pop r7
 1387 054e 6F90      		pop r6
 1388               	.LVL160:
 1389 0550 0895      		ret
 1390               		.cfi_endproc
 1391               	.LFE22:
 1393               	.global	box_walls
 1395               	box_walls:
 1396               	.LFB21:
 264:draw.c        **** {
 1397               		.loc 1 264 0
 1398               		.cfi_startproc
 1399               	.LVL161:
 1400 0552 2F92      		push r2
 1401               	.LCFI44:
 1402               		.cfi_def_cfa_offset 3
 1403               		.cfi_offset 2, -2
 1404 0554 3F92      		push r3
 1405               	.LCFI45:
 1406               		.cfi_def_cfa_offset 4
 1407               		.cfi_offset 3, -3
 1408 0556 4F92      		push r4
 1409               	.LCFI46:
 1410               		.cfi_def_cfa_offset 5
 1411               		.cfi_offset 4, -4
 1412 0558 5F92      		push r5
 1413               	.LCFI47:
 1414               		.cfi_def_cfa_offset 6
 1415               		.cfi_offset 5, -5
 1416 055a 6F92      		push r6
 1417               	.LCFI48:
 1418               		.cfi_def_cfa_offset 7
 1419               		.cfi_offset 6, -6
 1420 055c 7F92      		push r7
 1421               	.LCFI49:
 1422               		.cfi_def_cfa_offset 8
 1423               		.cfi_offset 7, -7
 1424 055e 8F92      		push r8
 1425               	.LCFI50:
 1426               		.cfi_def_cfa_offset 9
 1427               		.cfi_offset 8, -8
 1428 0560 9F92      		push r9
 1429               	.LCFI51:
 1430               		.cfi_def_cfa_offset 10
 1431               		.cfi_offset 9, -9
 1432 0562 AF92      		push r10
 1433               	.LCFI52:
 1434               		.cfi_def_cfa_offset 11
 1435               		.cfi_offset 10, -10
 1436 0564 BF92      		push r11
 1437               	.LCFI53:
 1438               		.cfi_def_cfa_offset 12
 1439               		.cfi_offset 11, -11
 1440 0566 CF92      		push r12
 1441               	.LCFI54:
 1442               		.cfi_def_cfa_offset 13
 1443               		.cfi_offset 12, -12
 1444 0568 DF92      		push r13
 1445               	.LCFI55:
 1446               		.cfi_def_cfa_offset 14
 1447               		.cfi_offset 13, -13
 1448 056a EF92      		push r14
 1449               	.LCFI56:
 1450               		.cfi_def_cfa_offset 15
 1451               		.cfi_offset 14, -14
 1452 056c FF92      		push r15
 1453               	.LCFI57:
 1454               		.cfi_def_cfa_offset 16
 1455               		.cfi_offset 15, -15
 1456 056e 0F93      		push r16
 1457               	.LCFI58:
 1458               		.cfi_def_cfa_offset 17
 1459               		.cfi_offset 16, -16
 1460 0570 1F93      		push r17
 1461               	.LCFI59:
 1462               		.cfi_def_cfa_offset 18
 1463               		.cfi_offset 17, -17
 1464 0572 CF93      		push r28
 1465               	.LCFI60:
 1466               		.cfi_def_cfa_offset 19
 1467               		.cfi_offset 28, -18
 1468 0574 DF93      		push r29
 1469               	.LCFI61:
 1470               		.cfi_def_cfa_offset 20
 1471               		.cfi_offset 29, -19
 1472 0576 00D0      		rcall .
 1473 0578 0F92      		push __tmp_reg__
 1474               	.LCFI62:
 1475               		.cfi_def_cfa_offset 23
 1476 057a CDB7      		in r28,__SP_L__
 1477 057c DEB7      		in r29,__SP_H__
 1478               	.LCFI63:
 1479               		.cfi_def_cfa_register 28
 1480               	/* prologue: function */
 1481               	/* frame size = 3 */
 1482               	/* stack size = 21 */
 1483               	.L__stack_usage = 21
 1484 057e 2C01      		movw r4,r24
 1485 0580 4B01      		movw r8,r22
 1486 0582 5A01      		movw r10,r20
 1487 0584 3901      		movw r6,r18
 1488 0586 6801      		movw r12,r16
 1489               	.LVL162:
 1490               	.LBB26:
 1491               	.LBB27:
  89:draw.c        **** 	if (ix1 > ix2)
 1492               		.loc 1 89 0
 1493 0588 2817      		cp r18,r24
 1494 058a 3907      		cpc r19,r25
 1495 058c 04F4      		brge .L74
 1496               	.LVL163:
 1497 058e 982F      		mov r25,r24
 1498 0590 852D      		mov r24,r5
 1499 0592 2901      		movw r4,r18
 1500               	.LVL164:
 1501 0594 692E      		mov r6,r25
 1502               	.LVL165:
 1503 0596 782E      		mov r7,r24
 1504               	.LVL166:
 1505               	.L74:
 1506               	.LBE27:
 1507               	.LBE26:
 1508               	.LBB28:
 1509               	.LBB29:
 1510 0598 C814      		cp r12,r8
 1511 059a D904      		cpc r13,r9
 1512 059c 04F4      		brge .L75
 1513 059e 982D      		mov r25,r8
 1514 05a0 892D      		mov r24,r9
 1515 05a2 4601      		movw r8,r12
 1516               	.LVL167:
 1517 05a4 C92E      		mov r12,r25
 1518               	.LVL168:
 1519 05a6 D82E      		mov r13,r24
 1520               	.L75:
 1521               	.LVL169:
 1522               	.LBE29:
 1523               	.LBE28:
 1524               	.LBB30:
 1525               	.LBB31:
 1526 05a8 EA14      		cp r14,r10
 1527 05aa FB04      		cpc r15,r11
 1528 05ac 04F4      		brge .L76
 1529 05ae 9A2D      		mov r25,r10
 1530 05b0 8B2D      		mov r24,r11
 1531 05b2 5701      		movw r10,r14
 1532               	.LVL170:
 1533 05b4 E92E      		mov r14,r25
 1534               	.LVL171:
 1535 05b6 F82E      		mov r15,r24
 1536               	.LVL172:
 1537               	.L76:
 1538               	.LBE31:
 1539               	.LBE30:
 281:draw.c        **** 				cube[iz][iy] |= ((0x01 << x1) | (0x01 << x2));
 1540               		.loc 1 281 0
 1541 05b8 81E0      		ldi r24,lo8(1)
 1542 05ba 90E0      		ldi r25,hi8(1)
 1543 05bc 9C01      		movw r18,r24
 1544 05be 062C      		mov r0,r6
 1545 05c0 00C0      		rjmp 2f
 1546 05c2 220F      	1:	lsl r18
 1547 05c4 331F      		rol r19
 1548 05c6 0A94      	2:	dec r0
 1549 05c8 02F4      		brpl 1b
 1550 05ca 042C      		mov r0,r4
 1551 05cc 00C0      		rjmp 2f
 1552 05ce 880F      	1:	lsl r24
 1553 05d0 991F      		rol r25
 1554 05d2 0A94      	2:	dec r0
 1555 05d4 02F4      		brpl 1b
 1556 05d6 282B      		or r18,r24
 272:draw.c        **** 	for (iz=z1;iz<=z2;iz++)
 1557               		.loc 1 272 0
 1558 05d8 8501      		movw r16,r10
 1559 05da 00C0      		rjmp .L77
 1560               	.LVL173:
 1561               	.L81:
 276:draw.c        **** 			if (iy == y1 || iy == y2 || iz == z1 || iz == z2)
 1562               		.loc 1 276 0
 1563 05dc 4815      		cp r20,r8
 1564 05de 5905      		cpc r21,r9
 1565 05e0 01F0      		breq .L78
 276:draw.c        **** 			if (iy == y1 || iy == y2 || iz == z1 || iz == z2)
 1566               		.loc 1 276 0 is_stmt 0 discriminator 1
 1567 05e2 4C15      		cp r20,r12
 1568 05e4 5D05      		cpc r21,r13
 1569 05e6 01F0      		breq .L78
 1570 05e8 0A15      		cp r16,r10
 1571 05ea 1B05      		cpc r17,r11
 1572 05ec 01F0      		breq .L78
 1573 05ee 0E15      		cp r16,r14
 1574 05f0 1F05      		cpc r17,r15
 1575 05f2 01F4      		brne .L79
 1576               	.L78:
 278:draw.c        **** 				cube[iz][iy] = byteline(x1,x2);
 1577               		.loc 1 278 0 is_stmt 1
 1578 05f4 C201      		movw r24,r4
 1579 05f6 B301      		movw r22,r6
 1580 05f8 2B83      		std Y+3,r18
 1581 05fa 4983      		std Y+1,r20
 1582 05fc 5A83      		std Y+2,r21
 1583 05fe 0E94 0000 		call byteline
 1584               	.LVL174:
 1585 0602 4981      		ldd r20,Y+1
 1586 0604 5A81      		ldd r21,Y+2
 1587 0606 F101      		movw r30,r2
 1588 0608 E40F      		add r30,r20
 1589 060a F51F      		adc r31,r21
 1590 060c E050      		subi r30,lo8(-(cube))
 1591 060e F040      		sbci r31,hi8(-(cube))
 1592 0610 8083      		st Z,r24
 1593 0612 2B81      		ldd r18,Y+3
 1594 0614 00C0      		rjmp .L80
 1595               	.LVL175:
 1596               	.L79:
 281:draw.c        **** 				cube[iz][iy] |= ((0x01 << x1) | (0x01 << x2));
 1597               		.loc 1 281 0
 1598 0616 F101      		movw r30,r2
 1599 0618 E40F      		add r30,r20
 1600 061a F51F      		adc r31,r21
 1601 061c E050      		subi r30,lo8(-(cube))
 1602 061e F040      		sbci r31,hi8(-(cube))
 1603 0620 8081      		ld r24,Z
 1604 0622 822B      		or r24,r18
 1605 0624 8083      		st Z,r24
 1606               	.LVL176:
 1607               	.L80:
 274:draw.c        **** 		for (iy=y1;iy<=y2;iy++)
 1608               		.loc 1 274 0
 1609 0626 4F5F      		subi r20,lo8(-(1))
 1610 0628 5F4F      		sbci r21,hi8(-(1))
 1611               	.LVL177:
 1612               	.L83:
 274:draw.c        **** 		for (iy=y1;iy<=y2;iy++)
 1613               		.loc 1 274 0 is_stmt 0 discriminator 1
 1614 062a C416      		cp r12,r20
 1615 062c D506      		cpc r13,r21
 1616 062e 04F4      		brge .L81
 272:draw.c        **** 	for (iz=z1;iz<=z2;iz++)
 1617               		.loc 1 272 0 is_stmt 1
 1618 0630 0F5F      		subi r16,lo8(-(1))
 1619 0632 1F4F      		sbci r17,hi8(-(1))
 1620               	.LVL178:
 1621               	.L77:
 272:draw.c        **** 	for (iz=z1;iz<=z2;iz++)
 1622               		.loc 1 272 0 is_stmt 0 discriminator 1
 1623 0634 E016      		cp r14,r16
 1624 0636 F106      		cpc r15,r17
 1625 0638 04F0      		brlt .L73
 1626 063a A401      		movw r20,r8
 1627 063c 1801      		movw r2,r16
 1628 063e 83E0      		ldi r24,3
 1629 0640 220C      	1:	lsl r2
 1630 0642 331C      		rol r3
 1631 0644 8A95      		dec r24
 1632 0646 01F4      		brne 1b
 1633 0648 00C0      		rjmp .L83
 1634               	.L73:
 1635               	/* epilogue start */
 286:draw.c        **** }
 1636               		.loc 1 286 0 is_stmt 1
 1637 064a 0F90      		pop __tmp_reg__
 1638 064c 0F90      		pop __tmp_reg__
 1639 064e 0F90      		pop __tmp_reg__
 1640 0650 DF91      		pop r29
 1641 0652 CF91      		pop r28
 1642 0654 1F91      		pop r17
 1643 0656 0F91      		pop r16
 1644               	.LVL179:
 1645 0658 FF90      		pop r15
 1646 065a EF90      		pop r14
 1647               	.LVL180:
 1648 065c DF90      		pop r13
 1649 065e CF90      		pop r12
 1650               	.LVL181:
 1651 0660 BF90      		pop r11
 1652 0662 AF90      		pop r10
 1653               	.LVL182:
 1654 0664 9F90      		pop r9
 1655 0666 8F90      		pop r8
 1656               	.LVL183:
 1657 0668 7F90      		pop r7
 1658 066a 6F90      		pop r6
 1659               	.LVL184:
 1660 066c 5F90      		pop r5
 1661 066e 4F90      		pop r4
 1662               	.LVL185:
 1663 0670 3F90      		pop r3
 1664 0672 2F90      		pop r2
 1665 0674 0895      		ret
 1666               		.cfi_endproc
 1667               	.LFE21:
 1669               	.global	box_filled
 1671               	box_filled:
 1672               	.LFB20:
 244:draw.c        **** {
 1673               		.loc 1 244 0
 1674               		.cfi_startproc
 1675               	.LVL186:
 1676 0676 2F92      		push r2
 1677               	.LCFI64:
 1678               		.cfi_def_cfa_offset 3
 1679               		.cfi_offset 2, -2
 1680 0678 3F92      		push r3
 1681               	.LCFI65:
 1682               		.cfi_def_cfa_offset 4
 1683               		.cfi_offset 3, -3
 1684 067a 4F92      		push r4
 1685               	.LCFI66:
 1686               		.cfi_def_cfa_offset 5
 1687               		.cfi_offset 4, -4
 1688 067c 5F92      		push r5
 1689               	.LCFI67:
 1690               		.cfi_def_cfa_offset 6
 1691               		.cfi_offset 5, -5
 1692 067e 6F92      		push r6
 1693               	.LCFI68:
 1694               		.cfi_def_cfa_offset 7
 1695               		.cfi_offset 6, -6
 1696 0680 7F92      		push r7
 1697               	.LCFI69:
 1698               		.cfi_def_cfa_offset 8
 1699               		.cfi_offset 7, -7
 1700 0682 8F92      		push r8
 1701               	.LCFI70:
 1702               		.cfi_def_cfa_offset 9
 1703               		.cfi_offset 8, -8
 1704 0684 9F92      		push r9
 1705               	.LCFI71:
 1706               		.cfi_def_cfa_offset 10
 1707               		.cfi_offset 9, -9
 1708 0686 AF92      		push r10
 1709               	.LCFI72:
 1710               		.cfi_def_cfa_offset 11
 1711               		.cfi_offset 10, -10
 1712 0688 BF92      		push r11
 1713               	.LCFI73:
 1714               		.cfi_def_cfa_offset 12
 1715               		.cfi_offset 11, -11
 1716 068a CF92      		push r12
 1717               	.LCFI74:
 1718               		.cfi_def_cfa_offset 13
 1719               		.cfi_offset 12, -12
 1720 068c DF92      		push r13
 1721               	.LCFI75:
 1722               		.cfi_def_cfa_offset 14
 1723               		.cfi_offset 13, -13
 1724 068e EF92      		push r14
 1725               	.LCFI76:
 1726               		.cfi_def_cfa_offset 15
 1727               		.cfi_offset 14, -14
 1728 0690 FF92      		push r15
 1729               	.LCFI77:
 1730               		.cfi_def_cfa_offset 16
 1731               		.cfi_offset 15, -15
 1732 0692 0F93      		push r16
 1733               	.LCFI78:
 1734               		.cfi_def_cfa_offset 17
 1735               		.cfi_offset 16, -16
 1736 0694 1F93      		push r17
 1737               	.LCFI79:
 1738               		.cfi_def_cfa_offset 18
 1739               		.cfi_offset 17, -17
 1740 0696 CF93      		push r28
 1741               	.LCFI80:
 1742               		.cfi_def_cfa_offset 19
 1743               		.cfi_offset 28, -18
 1744 0698 DF93      		push r29
 1745               	.LCFI81:
 1746               		.cfi_def_cfa_offset 20
 1747               		.cfi_offset 29, -19
 1748 069a 00D0      		rcall .
 1749 069c 0F92      		push __tmp_reg__
 1750               	.LCFI82:
 1751               		.cfi_def_cfa_offset 23
 1752 069e CDB7      		in r28,__SP_L__
 1753 06a0 DEB7      		in r29,__SP_H__
 1754               	.LCFI83:
 1755               		.cfi_def_cfa_register 28
 1756               	/* prologue: function */
 1757               	/* frame size = 3 */
 1758               	/* stack size = 21 */
 1759               	.L__stack_usage = 21
 1760 06a2 1C01      		movw r2,r24
 1761 06a4 2B01      		movw r4,r22
 1762 06a6 3901      		movw r6,r18
 1763 06a8 4801      		movw r8,r16
 1764 06aa 5701      		movw r10,r14
 1765               	.LVL187:
 1766               	.LBB32:
 1767               	.LBB33:
  89:draw.c        **** 	if (ix1 > ix2)
 1768               		.loc 1 89 0
 1769 06ac 2817      		cp r18,r24
 1770 06ae 3907      		cpc r19,r25
 1771 06b0 04F4      		brge .L88
 1772               	.LVL188:
 1773 06b2 982F      		mov r25,r24
 1774 06b4 832D      		mov r24,r3
 1775 06b6 1901      		movw r2,r18
 1776               	.LVL189:
 1777 06b8 692E      		mov r6,r25
 1778               	.LVL190:
 1779 06ba 782E      		mov r7,r24
 1780               	.LVL191:
 1781               	.L88:
 1782               	.LBE33:
 1783               	.LBE32:
 1784               	.LBB34:
 1785               	.LBB35:
 1786 06bc 8414      		cp r8,r4
 1787 06be 9504      		cpc r9,r5
 1788 06c0 04F4      		brge .L89
 1789 06c2 942D      		mov r25,r4
 1790 06c4 852D      		mov r24,r5
 1791 06c6 2401      		movw r4,r8
 1792               	.LVL192:
 1793 06c8 892E      		mov r8,r25
 1794               	.LVL193:
 1795 06ca 982E      		mov r9,r24
 1796               	.L89:
 1797               	.LVL194:
 1798               	.LBE35:
 1799               	.LBE34:
 1800               	.LBB36:
 1801               	.LBB37:
 1802 06cc A416      		cp r10,r20
 1803 06ce B506      		cpc r11,r21
 1804 06d0 04F4      		brge .L90
 1805               	.LVL195:
 1806 06d2 942F      		mov r25,r20
 1807 06d4 852F      		mov r24,r21
 1808 06d6 A501      		movw r20,r10
 1809               	.LVL196:
 1810 06d8 A92E      		mov r10,r25
 1811               	.LVL197:
 1812 06da B82E      		mov r11,r24
 1813               	.L90:
 1814               	.LVL198:
 1815               	.LBE37:
 1816               	.LBE36:
 252:draw.c        **** 	for (iz=z1;iz<=z2;iz++)
 1817               		.loc 1 252 0
 1818 06dc 6A01      		movw r12,r20
 1819 06de 00C0      		rjmp .L91
 1820               	.LVL199:
 1821               	.L92:
 256:draw.c        **** 			cube[iz][iy] |= byteline(x1,x2);
 1822               		.loc 1 256 0 discriminator 2
 1823 06e0 8901      		movw r16,r18
 1824 06e2 0E0D      		add r16,r14
 1825 06e4 1F1D      		adc r17,r15
 1826 06e6 0050      		subi r16,lo8(-(cube))
 1827 06e8 1040      		sbci r17,hi8(-(cube))
 1828 06ea F801      		movw r30,r16
 1829 06ec 4081      		ld r20,Z
 1830 06ee C101      		movw r24,r2
 1831 06f0 B301      		movw r22,r6
 1832 06f2 2A83      		std Y+2,r18
 1833 06f4 3B83      		std Y+3,r19
 1834 06f6 4983      		std Y+1,r20
 1835 06f8 0E94 0000 		call byteline
 1836 06fc 4981      		ldd r20,Y+1
 1837 06fe 842B      		or r24,r20
 1838 0700 F801      		movw r30,r16
 1839 0702 8083      		st Z,r24
 254:draw.c        **** 		for (iy=y1;iy<=y2;iy++)
 1840               		.loc 1 254 0 discriminator 2
 1841 0704 0894      		sec
 1842 0706 E11C      		adc r14,__zero_reg__
 1843 0708 F11C      		adc r15,__zero_reg__
 1844               	.LVL200:
 1845 070a 3B81      		ldd r19,Y+3
 1846 070c 2A81      		ldd r18,Y+2
 1847               	.LVL201:
 1848               	.L94:
 254:draw.c        **** 		for (iy=y1;iy<=y2;iy++)
 1849               		.loc 1 254 0 is_stmt 0 discriminator 1
 1850 070e 8E14      		cp r8,r14
 1851 0710 9F04      		cpc r9,r15
 1852 0712 04F4      		brge .L92
 252:draw.c        **** 	for (iz=z1;iz<=z2;iz++)
 1853               		.loc 1 252 0 is_stmt 1
 1854 0714 0894      		sec
 1855 0716 C11C      		adc r12,__zero_reg__
 1856 0718 D11C      		adc r13,__zero_reg__
 1857               	.LVL202:
 1858               	.L91:
 252:draw.c        **** 	for (iz=z1;iz<=z2;iz++)
 1859               		.loc 1 252 0 is_stmt 0 discriminator 1
 1860 071a AC14      		cp r10,r12
 1861 071c BD04      		cpc r11,r13
 1862 071e 04F0      		brlt .L87
 1863 0720 7201      		movw r14,r4
 256:draw.c        **** 			cube[iz][iy] |= byteline(x1,x2);
 1864               		.loc 1 256 0 is_stmt 1 discriminator 1
 1865 0722 9601      		movw r18,r12
 1866 0724 93E0      		ldi r25,3
 1867 0726 220F      	1:	lsl r18
 1868 0728 331F      		rol r19
 1869 072a 9A95      		dec r25
 1870 072c 01F4      		brne 1b
 1871 072e 00C0      		rjmp .L94
 1872               	.L87:
 1873               	/* epilogue start */
 260:draw.c        **** }
 1874               		.loc 1 260 0
 1875 0730 0F90      		pop __tmp_reg__
 1876 0732 0F90      		pop __tmp_reg__
 1877 0734 0F90      		pop __tmp_reg__
 1878 0736 DF91      		pop r29
 1879 0738 CF91      		pop r28
 1880 073a 1F91      		pop r17
 1881 073c 0F91      		pop r16
 1882 073e FF90      		pop r15
 1883 0740 EF90      		pop r14
 1884 0742 DF90      		pop r13
 1885 0744 CF90      		pop r12
 1886               	.LVL203:
 1887 0746 BF90      		pop r11
 1888 0748 AF90      		pop r10
 1889               	.LVL204:
 1890 074a 9F90      		pop r9
 1891 074c 8F90      		pop r8
 1892               	.LVL205:
 1893 074e 7F90      		pop r7
 1894 0750 6F90      		pop r6
 1895               	.LVL206:
 1896 0752 5F90      		pop r5
 1897 0754 4F90      		pop r4
 1898               	.LVL207:
 1899 0756 3F90      		pop r3
 1900 0758 2F90      		pop r2
 1901               	.LVL208:
 1902 075a 0895      		ret
 1903               		.cfi_endproc
 1904               	.LFE20:
 1906               	.global	flipbyte
 1908               	flipbyte:
 1909               	.LFB24:
 331:draw.c        **** 
 332:draw.c        **** // Flips a byte 180 degrees.
 333:draw.c        **** // MSB becomes LSB, LSB becomes MSB.
 334:draw.c        **** char flipbyte (char byte)
 335:draw.c        **** {
 1910               		.loc 1 335 0
 1911               		.cfi_startproc
 1912               	.LVL209:
 1913               	/* prologue: function */
 1914               	/* frame size = 0 */
 1915               	/* stack size = 0 */
 1916               	.L__stack_usage = 0
 336:draw.c        **** 	char flop = 0x00;
 337:draw.c        **** 
 338:draw.c        **** 	flop = (flop & 0b11111110) | (0b00000001 & (byte >> 7));
 339:draw.c        **** 	flop = (flop & 0b11111101) | (0b00000010 & (byte >> 5));
 340:draw.c        **** 	flop = (flop & 0b11111011) | (0b00000100 & (byte >> 3));
 341:draw.c        **** 	flop = (flop & 0b11110111) | (0b00001000 & (byte >> 1));
 342:draw.c        **** 	flop = (flop & 0b11101111) | (0b00010000 & (byte << 1));
 1917               		.loc 1 342 0
 1918 075c 282F      		mov r18,r24
 1919 075e 30E0      		ldi r19,lo8(0)
 1920               	.LVL210:
 339:draw.c        **** 	flop = (flop & 0b11111101) | (0b00000010 & (byte >> 5));
 1921               		.loc 1 339 0
 1922 0760 982F      		mov r25,r24
 1923 0762 9295      		swap r25
 1924 0764 9695      		lsr r25
 1925 0766 9270      		andi r25,lo8(2)
 1926 0768 482F      		mov r20,r24
 1927 076a 441F      		rol r20
 1928 076c 4427      		clr r20
 1929 076e 441F      		rol r20
 340:draw.c        **** 	flop = (flop & 0b11111011) | (0b00000100 & (byte >> 3));
 1930               		.loc 1 340 0
 1931 0770 942B      		or r25,r20
 1932 0772 482F      		mov r20,r24
 1933 0774 4695      		lsr r20
 1934 0776 4695      		lsr r20
 1935 0778 4695      		lsr r20
 1936 077a 4470      		andi r20,lo8(4)
 341:draw.c        **** 	flop = (flop & 0b11110111) | (0b00001000 & (byte >> 1));
 1937               		.loc 1 341 0
 1938 077c 942B      		or r25,r20
 1939 077e 8695      		lsr r24
 1940               	.LVL211:
 1941 0780 8870      		andi r24,lo8(8)
 1942               		.loc 1 342 0
 1943 0782 982B      		or r25,r24
 1944 0784 A901      		movw r20,r18
 1945 0786 440F      		lsl r20
 1946 0788 551F      		rol r21
 1947 078a 4071      		andi r20,lo8(16)
 343:draw.c        **** 	flop = (flop & 0b11011111) | (0b00100000 & (byte << 3));
 1948               		.loc 1 343 0
 1949 078c 942B      		or r25,r20
 1950 078e A901      		movw r20,r18
 1951 0790 73E0      		ldi r23,3
 1952 0792 440F      	1:	lsl r20
 1953 0794 551F      		rol r21
 1954 0796 7A95      		dec r23
 1955 0798 01F4      		brne 1b
 1956 079a 4072      		andi r20,lo8(32)
 344:draw.c        **** 	flop = (flop & 0b10111111) | (0b01000000 & (byte << 5));
 1957               		.loc 1 344 0
 1958 079c 942B      		or r25,r20
 1959 079e A901      		movw r20,r18
 1960 07a0 E5E0      		ldi r30,5
 1961 07a2 440F      	1:	lsl r20
 1962 07a4 551F      		rol r21
 1963 07a6 EA95      		dec r30
 1964 07a8 01F4      		brne 1b
 1965 07aa 4074      		andi r20,lo8(64)
 345:draw.c        **** 	flop = (flop & 0b01111111) | (0b10000000 & (byte << 7));
 1966               		.loc 1 345 0
 1967 07ac 942B      		or r25,r20
 1968 07ae 3695      		lsr r19
 1969 07b0 322F      		mov r19,r18
 1970 07b2 2227      		clr r18
 1971 07b4 3795      		ror r19
 1972 07b6 2795      		ror r18
 1973               	.LVL212:
 346:draw.c        **** 	return flop;
 347:draw.c        **** }
 1974               		.loc 1 347 0
 1975 07b8 892F      		mov r24,r25
 1976 07ba 822B      		or r24,r18
 1977               	/* epilogue start */
 1978 07bc 0895      		ret
 1979               		.cfi_endproc
 1980               	.LFE24:
 1982               	.global	line
 1984               	line:
 1985               	.LFB25:
 348:draw.c        **** 
 349:draw.c        **** // Draw a line between any coordinates in 3d space.
 350:draw.c        **** // Uses integer values for input, so dont expect smooth animations.
 351:draw.c        **** void line(int x1, int y1, int z1, int x2, int y2, int z2)
 352:draw.c        **** {
 1986               		.loc 1 352 0
 1987               		.cfi_startproc
 1988               	.LVL213:
 1989 07be 2F92      		push r2
 1990               	.LCFI84:
 1991               		.cfi_def_cfa_offset 3
 1992               		.cfi_offset 2, -2
 1993 07c0 3F92      		push r3
 1994               	.LCFI85:
 1995               		.cfi_def_cfa_offset 4
 1996               		.cfi_offset 3, -3
 1997 07c2 4F92      		push r4
 1998               	.LCFI86:
 1999               		.cfi_def_cfa_offset 5
 2000               		.cfi_offset 4, -4
 2001 07c4 5F92      		push r5
 2002               	.LCFI87:
 2003               		.cfi_def_cfa_offset 6
 2004               		.cfi_offset 5, -5
 2005 07c6 6F92      		push r6
 2006               	.LCFI88:
 2007               		.cfi_def_cfa_offset 7
 2008               		.cfi_offset 6, -6
 2009 07c8 7F92      		push r7
 2010               	.LCFI89:
 2011               		.cfi_def_cfa_offset 8
 2012               		.cfi_offset 7, -7
 2013 07ca 8F92      		push r8
 2014               	.LCFI90:
 2015               		.cfi_def_cfa_offset 9
 2016               		.cfi_offset 8, -8
 2017 07cc 9F92      		push r9
 2018               	.LCFI91:
 2019               		.cfi_def_cfa_offset 10
 2020               		.cfi_offset 9, -9
 2021 07ce AF92      		push r10
 2022               	.LCFI92:
 2023               		.cfi_def_cfa_offset 11
 2024               		.cfi_offset 10, -10
 2025 07d0 BF92      		push r11
 2026               	.LCFI93:
 2027               		.cfi_def_cfa_offset 12
 2028               		.cfi_offset 11, -11
 2029 07d2 CF92      		push r12
 2030               	.LCFI94:
 2031               		.cfi_def_cfa_offset 13
 2032               		.cfi_offset 12, -12
 2033 07d4 DF92      		push r13
 2034               	.LCFI95:
 2035               		.cfi_def_cfa_offset 14
 2036               		.cfi_offset 13, -13
 2037 07d6 EF92      		push r14
 2038               	.LCFI96:
 2039               		.cfi_def_cfa_offset 15
 2040               		.cfi_offset 14, -14
 2041 07d8 FF92      		push r15
 2042               	.LCFI97:
 2043               		.cfi_def_cfa_offset 16
 2044               		.cfi_offset 15, -15
 2045 07da 0F93      		push r16
 2046               	.LCFI98:
 2047               		.cfi_def_cfa_offset 17
 2048               		.cfi_offset 16, -16
 2049 07dc 1F93      		push r17
 2050               	.LCFI99:
 2051               		.cfi_def_cfa_offset 18
 2052               		.cfi_offset 17, -17
 2053 07de CF93      		push r28
 2054               	.LCFI100:
 2055               		.cfi_def_cfa_offset 19
 2056               		.cfi_offset 28, -18
 2057 07e0 DF93      		push r29
 2058               	.LCFI101:
 2059               		.cfi_def_cfa_offset 20
 2060               		.cfi_offset 29, -19
 2061 07e2 CDB7      		in r28,__SP_L__
 2062 07e4 DEB7      		in r29,__SP_H__
 2063 07e6 6297      		sbiw r28,18
 2064               	.LCFI102:
 2065               		.cfi_def_cfa 28, 38
 2066 07e8 0FB6      		in __tmp_reg__,__SREG__
 2067 07ea F894      		cli
 2068 07ec DEBF      		out __SP_H__,r29
 2069 07ee 0FBE      		out __SREG__,__tmp_reg__
 2070 07f0 CDBF      		out __SP_L__,r28
 2071               	/* prologue: function */
 2072               	/* frame size = 18 */
 2073               	/* stack size = 36 */
 2074               	.L__stack_usage = 36
 2075 07f2 9A83      		std Y+2,r25
 2076 07f4 8983      		std Y+1,r24
 2077 07f6 2B01      		movw r4,r22
 2078 07f8 5A01      		movw r10,r20
 2079 07fa 3C83      		std Y+4,r19
 2080 07fc 2B83      		std Y+3,r18
 2081 07fe B801      		movw r22,r16
 2082               	.LVL214:
 2083 0800 1701      		movw r2,r14
 353:draw.c        **** 	float xy;	// how many voxels do we move on the y axis for each step on the x axis
 354:draw.c        **** 	float xz;	// how many voxels do we move on the y axis for each step on the x axis 
 355:draw.c        **** 	unsigned char x,y,z;
 356:draw.c        **** 	unsigned char lasty,lastz;
 357:draw.c        **** 
 358:draw.c        **** 	// We always want to draw the line from x=0 to x=7.
 359:draw.c        **** 	// If x1 is bigget than x2, we need to flip all the values.
 360:draw.c        **** 	if (x1>x2)
 2084               		.loc 1 360 0
 2085 0802 2817      		cp r18,r24
 2086 0804 3907      		cpc r19,r25
 2087 0806 04F4      		brge .L100
 2088               	.LVL215:
 2089 0808 8B2D      		mov r24,r11
 2090               	.LVL216:
 361:draw.c        **** 	{
 362:draw.c        **** 		int tmp;
 363:draw.c        **** 		tmp = x2; x2 = x1; x1 = tmp;
 364:draw.c        **** 		tmp = y2; y2 = y1; y1 = tmp;
 365:draw.c        **** 		tmp = z2; z2 = z1; z1 = tmp;
 2091               		.loc 1 365 0
 2092 080a 5701      		movw r10,r14
 2093               	.LVL217:
 2094 080c 242E      		mov r2,r20
 2095               	.LVL218:
 2096 080e 382E      		mov r3,r24
 360:draw.c        **** 	if (x1>x2)
 2097               		.loc 1 360 0
 2098 0810 942D      		mov r25,r4
 2099 0812 852D      		mov r24,r5
 364:draw.c        **** 		tmp = y2; y2 = y1; y1 = tmp;
 2100               		.loc 1 364 0
 2101 0814 2801      		movw r4,r16
 2102               	.LVL219:
 2103 0816 692F      		mov r22,r25
 2104 0818 782F      		mov r23,r24
 360:draw.c        **** 	if (x1>x2)
 2105               		.loc 1 360 0
 2106 081a 9981      		ldd r25,Y+1
 2107 081c 8A81      		ldd r24,Y+2
 2108 081e 3A83      		std Y+2,r19
 2109 0820 2983      		std Y+1,r18
 2110 0822 9B83      		std Y+3,r25
 2111 0824 8C83      		std Y+4,r24
 2112               	.LVL220:
 2113               	.L100:
 2114 0826 0B81      		ldd r16,Y+3
 2115 0828 1C81      		ldd r17,Y+4
 2116 082a 8981      		ldd r24,Y+1
 2117 082c 9A81      		ldd r25,Y+2
 2118 082e 081B      		sub r16,r24
 2119 0830 190B      		sbc r17,r25
 366:draw.c        **** 	}
 367:draw.c        **** 
 368:draw.c        **** 	
 369:draw.c        **** 	if (y1>y2)
 2120               		.loc 1 369 0
 2121 0832 6415      		cp r22,r4
 2122 0834 7505      		cpc r23,r5
 2123 0836 04F4      		brge .L101
 370:draw.c        **** 	{
 371:draw.c        **** 		xy = (float)(y1-y2)/(float)(x2-x1);
 2124               		.loc 1 371 0
 2125 0838 D201      		movw r26,r4
 2126 083a A61B      		sub r26,r22
 2127 083c B70B      		sbc r27,r23
 2128 083e BD01      		movw r22,r26
 2129               	.LVL221:
 2130 0840 00C0      		rjmp .L108
 2131               	.LVL222:
 2132               	.L101:
 372:draw.c        **** 		lasty = y2;
 373:draw.c        **** 	} else
 374:draw.c        **** 	{
 375:draw.c        **** 		xy = (float)(y2-y1)/(float)(x2-x1);
 2133               		.loc 1 375 0
 2134 0842 6419      		sub r22,r4
 2135 0844 7509      		sbc r23,r5
 2136               	.LVL223:
 2137               	.L108:
 2138 0846 8827      		clr r24
 2139 0848 77FD      		sbrc r23,7
 2140 084a 8095      		com r24
 2141 084c 982F      		mov r25,r24
 2142 084e 0E94 0000 		call __floatsisf
 2143 0852 6B01      		movw r12,r22
 2144 0854 7C01      		movw r14,r24
 2145 0856 B801      		movw r22,r16
 2146 0858 8827      		clr r24
 2147 085a 77FD      		sbrc r23,7
 2148 085c 8095      		com r24
 2149 085e 982F      		mov r25,r24
 2150 0860 0E94 0000 		call __floatsisf
 2151 0864 9B01      		movw r18,r22
 2152 0866 AC01      		movw r20,r24
 2153 0868 C701      		movw r24,r14
 2154 086a B601      		movw r22,r12
 2155 086c 0E94 0000 		call __divsf3
 2156 0870 6D83      		std Y+5,r22
 2157 0872 7E83      		std Y+6,r23
 2158 0874 8F83      		std Y+7,r24
 2159 0876 692E      		mov r6,r25
 2160               	.LVL224:
 2161 0878 8B80      		ldd r8,Y+3
 2162 087a 9C80      		ldd r9,Y+4
 2163 087c E981      		ldd r30,Y+1
 2164 087e FA81      		ldd r31,Y+2
 2165 0880 8E1A      		sub r8,r30
 2166 0882 9F0A      		sbc r9,r31
 376:draw.c        **** 		lasty = y1;
 377:draw.c        **** 	}
 378:draw.c        **** 
 379:draw.c        **** 	if (z1>z2)
 2167               		.loc 1 379 0
 2168 0884 2A14      		cp r2,r10
 2169 0886 3B04      		cpc r3,r11
 2170 0888 04F4      		brge .L103
 380:draw.c        **** 	{
 381:draw.c        **** 		xz = (float)(z1-z2)/(float)(x2-x1);
 2171               		.loc 1 381 0
 2172 088a B501      		movw r22,r10
 2173               	.LVL225:
 2174 088c 6219      		sub r22,r2
 2175 088e 7309      		sbc r23,r3
 2176 0890 00C0      		rjmp .L109
 2177               	.L103:
 382:draw.c        **** 		lastz = z2;
 383:draw.c        **** 	} else
 384:draw.c        **** 	{
 385:draw.c        **** 		xz = (float)(z2-z1)/(float)(x2-x1);
 2178               		.loc 1 385 0
 2179 0892 B101      		movw r22,r2
 2180 0894 6A19      		sub r22,r10
 2181 0896 7B09      		sbc r23,r11
 2182               	.L109:
 2183 0898 8827      		clr r24
 2184 089a 77FD      		sbrc r23,7
 2185 089c 8095      		com r24
 2186 089e 982F      		mov r25,r24
 2187 08a0 0E94 0000 		call __floatsisf
 2188               	.LVL226:
 2189 08a4 6B01      		movw r12,r22
 2190 08a6 7C01      		movw r14,r24
 2191 08a8 B401      		movw r22,r8
 2192 08aa 8827      		clr r24
 2193 08ac 77FD      		sbrc r23,7
 2194 08ae 8095      		com r24
 2195 08b0 982F      		mov r25,r24
 2196 08b2 0E94 0000 		call __floatsisf
 2197 08b6 9B01      		movw r18,r22
 2198 08b8 AC01      		movw r20,r24
 2199 08ba C701      		movw r24,r14
 2200 08bc B601      		movw r22,r12
 2201 08be 0E94 0000 		call __divsf3
 2202 08c2 762E      		mov r7,r22
 2203 08c4 072F      		mov r16,r23
 2204 08c6 182F      		mov r17,r24
 2205 08c8 292F      		mov r18,r25
 2206               	.LVL227:
 386:draw.c        **** 		lastz = z1;
 387:draw.c        **** 	}
 388:draw.c        **** 
 389:draw.c        **** 
 390:draw.c        **** 
 391:draw.c        **** 	// For each step of x, y increments by:
 392:draw.c        **** 	for (x = x1; x<=x2;x++)
 2207               		.loc 1 392 0
 2208 08ca F981      		ldd r31,Y+1
 2209 08cc F887      		std Y+8,r31
 2210               	.LVL228:
 2211 08ce 2224      		clr r2
 2212 08d0 3324      		clr r3
 2213               	.LVL229:
 393:draw.c        **** 	{
 394:draw.c        **** 		y = (xy*(x-x1))+y1;
 2214               		.loc 1 394 0
 2215 08d2 C201      		movw r24,r4
 2216 08d4 AA27      		clr r26
 2217 08d6 97FD      		sbrc r25,7
 2218 08d8 A095      		com r26
 2219 08da BA2F      		mov r27,r26
 2220               	.LVL230:
 2221 08dc 8987      		std Y+9,r24
 2222 08de 9A87      		std Y+10,r25
 2223 08e0 AB87      		std Y+11,r26
 2224 08e2 BC87      		std Y+12,r27
 395:draw.c        **** 		z = (xz*(x-x1))+z1;
 2225               		.loc 1 395 0
 2226 08e4 C501      		movw r24,r10
 2227 08e6 AA27      		clr r26
 2228 08e8 97FD      		sbrc r25,7
 2229 08ea A095      		com r26
 2230 08ec BA2F      		mov r27,r26
 2231 08ee 8D87      		std Y+13,r24
 2232 08f0 9E87      		std Y+14,r25
 2233 08f2 AF87      		std Y+15,r26
 2234 08f4 B88B      		std Y+16,r27
 2235 08f6 2A8B      		std Y+18,r18
 392:draw.c        **** 	for (x = x1; x<=x2;x++)
 2236               		.loc 1 392 0
 2237 08f8 00C0      		rjmp .L105
 2238               	.LVL231:
 2239               	.L106:
 394:draw.c        **** 		y = (xy*(x-x1))+y1;
 2240               		.loc 1 394 0 discriminator 2
 2241 08fa B201      		movw r22,r4
 2242 08fc A981      		ldd r26,Y+1
 2243 08fe BA81      		ldd r27,Y+2
 2244 0900 6A1B      		sub r22,r26
 2245 0902 7B0B      		sbc r23,r27
 2246 0904 8827      		clr r24
 2247 0906 77FD      		sbrc r23,7
 2248 0908 8095      		com r24
 2249 090a 982F      		mov r25,r24
 2250 090c 0E94 0000 		call __floatsisf
 2251 0910 4B01      		movw r8,r22
 2252 0912 5C01      		movw r10,r24
 2253 0914 5D81      		ldd r21,Y+5
 2254 0916 4E81      		ldd r20,Y+6
 2255 0918 3F81      		ldd r19,Y+7
 2256 091a 852F      		mov r24,r21
 2257 091c 942F      		mov r25,r20
 2258 091e A32F      		mov r26,r19
 2259 0920 B62D      		mov r27,r6
 2260 0922 BC01      		movw r22,r24
 2261 0924 CD01      		movw r24,r26
 2262 0926 A501      		movw r20,r10
 2263 0928 9401      		movw r18,r8
 2264 092a 0E94 0000 		call __mulsf3
 2265 092e 6B01      		movw r12,r22
 2266 0930 7C01      		movw r14,r24
 2267 0932 6985      		ldd r22,Y+9
 2268 0934 7A85      		ldd r23,Y+10
 2269 0936 8B85      		ldd r24,Y+11
 2270 0938 9C85      		ldd r25,Y+12
 2271 093a 0E94 0000 		call __floatsisf
 2272 093e 9B01      		movw r18,r22
 2273 0940 AC01      		movw r20,r24
 2274 0942 C701      		movw r24,r14
 2275 0944 B601      		movw r22,r12
 2276 0946 0E94 0000 		call __addsf3
 2277 094a 0E94 0000 		call __fixunssfsi
 2278 094e 698B      		std Y+17,r22
 2279               		.loc 1 395 0 discriminator 2
 2280 0950 2A89      		ldd r18,Y+18
 2281 0952 872D      		mov r24,r7
 2282 0954 902F      		mov r25,r16
 2283 0956 A12F      		mov r26,r17
 2284 0958 B22F      		mov r27,r18
 2285 095a BC01      		movw r22,r24
 2286 095c CD01      		movw r24,r26
 2287 095e A501      		movw r20,r10
 2288 0960 9401      		movw r18,r8
 2289 0962 0E94 0000 		call __mulsf3
 2290 0966 6B01      		movw r12,r22
 2291 0968 7C01      		movw r14,r24
 2292 096a 6D85      		ldd r22,Y+13
 2293 096c 7E85      		ldd r23,Y+14
 2294 096e 8F85      		ldd r24,Y+15
 2295 0970 9889      		ldd r25,Y+16
 2296 0972 0E94 0000 		call __floatsisf
 2297 0976 9B01      		movw r18,r22
 2298 0978 AC01      		movw r20,r24
 2299 097a C701      		movw r24,r14
 2300 097c B601      		movw r22,r12
 2301 097e 0E94 0000 		call __addsf3
 2302 0982 0E94 0000 		call __fixunssfsi
 2303 0986 462F      		mov r20,r22
 396:draw.c        **** 		setvoxel(x,y,z);
 2304               		.loc 1 396 0 discriminator 2
 2305 0988 C201      		movw r24,r4
 2306 098a 6989      		ldd r22,Y+17
 2307 098c 70E0      		ldi r23,lo8(0)
 2308 098e 50E0      		ldi r21,lo8(0)
 2309 0990 0E94 0000 		call setvoxel
 2310               	.LVL232:
 2311               	.L105:
 351:draw.c        **** void line(int x1, int y1, int z1, int x2, int y2, int z2)
 2312               		.loc 1 351 0 discriminator 1
 2313 0994 4884      		ldd r4,Y+8
 2314 0996 420C      		add r4,r2
 392:draw.c        **** 	for (x = x1; x<=x2;x++)
 2315               		.loc 1 392 0 discriminator 1
 2316 0998 5524      		clr r5
 2317 099a 0894      		sec
 2318 099c 211C      		adc r2,__zero_reg__
 2319 099e 311C      		adc r3,__zero_reg__
 2320               	.LVL233:
 2321 09a0 EB81      		ldd r30,Y+3
 2322 09a2 FC81      		ldd r31,Y+4
 2323 09a4 E415      		cp r30,r4
 2324 09a6 F505      		cpc r31,r5
 2325 09a8 04F0      		brlt .+2
 2326 09aa 00C0      		rjmp .L106
 2327               	/* epilogue start */
 397:draw.c        **** 	}
 398:draw.c        **** 	
 399:draw.c        **** }
 2328               		.loc 1 399 0
 2329 09ac 6296      		adiw r28,18
 2330               	.LVL234:
 2331 09ae 0FB6      		in __tmp_reg__,__SREG__
 2332 09b0 F894      		cli
 2333 09b2 DEBF      		out __SP_H__,r29
 2334 09b4 0FBE      		out __SREG__,__tmp_reg__
 2335 09b6 CDBF      		out __SP_L__,r28
 2336 09b8 DF91      		pop r29
 2337 09ba CF91      		pop r28
 2338               	.LVL235:
 2339 09bc 1F91      		pop r17
 2340               	.LVL236:
 2341 09be 0F91      		pop r16
 2342 09c0 FF90      		pop r15
 2343 09c2 EF90      		pop r14
 2344 09c4 DF90      		pop r13
 2345 09c6 CF90      		pop r12
 2346 09c8 BF90      		pop r11
 2347 09ca AF90      		pop r10
 2348               	.LVL237:
 2349 09cc 9F90      		pop r9
 2350 09ce 8F90      		pop r8
 2351 09d0 7F90      		pop r7
 2352 09d2 6F90      		pop r6
 2353               	.LVL238:
 2354 09d4 5F90      		pop r5
 2355 09d6 4F90      		pop r4
 2356 09d8 3F90      		pop r3
 2357 09da 2F90      		pop r2
 2358               	.LVL239:
 2359 09dc 0895      		ret
 2360               		.cfi_endproc
 2361               	.LFE25:
 2363               	.global	tmp2cube
 2365               	tmp2cube:
 2366               	.LFB26:
 400:draw.c        **** 
 401:draw.c        **** // Copies the contents of fb (temp cube buffer) into the rendering buffer
 402:draw.c        **** void tmp2cube (void)
 403:draw.c        **** {	
 2367               		.loc 1 403 0
 2368               		.cfi_startproc
 2369               	/* prologue: function */
 2370               	/* frame size = 0 */
 2371               	/* stack size = 0 */
 2372               	.L__stack_usage = 0
 404:draw.c        ****     memcpy(cube, fb, 64); // copy the current cube into a buffer.
 2373               		.loc 1 404 0
 2374 09de A0E0      		ldi r26,lo8(cube)
 2375 09e0 B0E0      		ldi r27,hi8(cube)
 2376 09e2 E0E0      		ldi r30,lo8(fb)
 2377 09e4 F0E0      		ldi r31,hi8(fb)
 2378 09e6 80E4      		ldi r24,lo8(64)
 2379               	.L111:
 2380 09e8 0190      		ld r0,Z+
 2381 09ea 0D92      		st X+,r0
 2382 09ec 8150      		subi r24,lo8(-(-1))
 2383 09ee 01F4      		brne .L111
 2384               	/* epilogue start */
 405:draw.c        **** }
 2385               		.loc 1 405 0
 2386 09f0 0895      		ret
 2387               		.cfi_endproc
 2388               	.LFE26:
 2390               	.global	shift
 2392               	shift:
 2393               	.LFB27:
 406:draw.c        **** 
 407:draw.c        **** // Shift the entire contents of the cube along an axis
 408:draw.c        **** // This is great for effects where you want to draw something
 409:draw.c        **** // on one side of the cube and have it flow towards the other
 410:draw.c        **** // side. Like rain flowing down the Z axiz.
 411:draw.c        **** void shift (char axis, int direction)
 412:draw.c        **** {
 2394               		.loc 1 412 0
 2395               		.cfi_startproc
 2396               	.LVL240:
 2397 09f2 4F92      		push r4
 2398               	.LCFI103:
 2399               		.cfi_def_cfa_offset 3
 2400               		.cfi_offset 4, -2
 2401 09f4 5F92      		push r5
 2402               	.LCFI104:
 2403               		.cfi_def_cfa_offset 4
 2404               		.cfi_offset 5, -3
 2405 09f6 6F92      		push r6
 2406               	.LCFI105:
 2407               		.cfi_def_cfa_offset 5
 2408               		.cfi_offset 6, -4
 2409 09f8 7F92      		push r7
 2410               	.LCFI106:
 2411               		.cfi_def_cfa_offset 6
 2412               		.cfi_offset 7, -5
 2413 09fa 8F92      		push r8
 2414               	.LCFI107:
 2415               		.cfi_def_cfa_offset 7
 2416               		.cfi_offset 8, -6
 2417 09fc 9F92      		push r9
 2418               	.LCFI108:
 2419               		.cfi_def_cfa_offset 8
 2420               		.cfi_offset 9, -7
 2421 09fe BF92      		push r11
 2422               	.LCFI109:
 2423               		.cfi_def_cfa_offset 9
 2424               		.cfi_offset 11, -8
 2425 0a00 CF92      		push r12
 2426               	.LCFI110:
 2427               		.cfi_def_cfa_offset 10
 2428               		.cfi_offset 12, -9
 2429 0a02 DF92      		push r13
 2430               	.LCFI111:
 2431               		.cfi_def_cfa_offset 11
 2432               		.cfi_offset 13, -10
 2433 0a04 EF92      		push r14
 2434               	.LCFI112:
 2435               		.cfi_def_cfa_offset 12
 2436               		.cfi_offset 14, -11
 2437 0a06 FF92      		push r15
 2438               	.LCFI113:
 2439               		.cfi_def_cfa_offset 13
 2440               		.cfi_offset 15, -12
 2441 0a08 0F93      		push r16
 2442               	.LCFI114:
 2443               		.cfi_def_cfa_offset 14
 2444               		.cfi_offset 16, -13
 2445 0a0a 1F93      		push r17
 2446               	.LCFI115:
 2447               		.cfi_def_cfa_offset 15
 2448               		.cfi_offset 17, -14
 2449 0a0c CF93      		push r28
 2450               	.LCFI116:
 2451               		.cfi_def_cfa_offset 16
 2452               		.cfi_offset 28, -15
 2453 0a0e DF93      		push r29
 2454               	.LCFI117:
 2455               		.cfi_def_cfa_offset 17
 2456               		.cfi_offset 29, -16
 2457               	/* prologue: function */
 2458               	/* frame size = 0 */
 2459               	/* stack size = 15 */
 2460               	.L__stack_usage = 15
 2461 0a10 C82E      		mov r12,r24
 2462 0a12 3B01      		movw r6,r22
 2463               	.LVL241:
 413:draw.c        **** 	int i, x ,y;
 414:draw.c        **** 	int ii, iii;
 415:draw.c        **** 	int state;
 416:draw.c        **** 
 417:draw.c        **** 	for (i = 0; i < CUBE_SIZE; i++)
 2464               		.loc 1 417 0
 2465 0a14 8824      		clr r8
 2466 0a16 9924      		clr r9
 411:draw.c        **** void shift (char axis, int direction)
 2467               		.loc 1 411 0
 2468 0a18 B7E0      		ldi r27,lo8(7)
 2469 0a1a 4B2E      		mov r4,r27
 2470 0a1c 512C      		mov r5,__zero_reg__
 2471               	.LVL242:
 2472               	.L123:
 418:draw.c        **** 	{
 419:draw.c        **** 		if (direction == -1)
 2473               		.loc 1 419 0
 2474 0a1e 4FEF      		ldi r20,lo8(-1)
 2475 0a20 6416      		cp r6,r20
 2476 0a22 4FEF      		ldi r20,hi8(-1)
 2477 0a24 7406      		cpc r7,r20
 2478 0a26 01F0      		breq .L131
 411:draw.c        **** void shift (char axis, int direction)
 2479               		.loc 1 411 0
 2480 0a28 7201      		movw r14,r4
 2481 0a2a E818      		sub r14,r8
 2482 0a2c F908      		sbc r15,r9
 2483               	.LVL243:
 2484 0a2e 00C0      		rjmp .L114
 2485               	.LVL244:
 2486               	.L131:
 2487               		.loc 1 419 0
 2488 0a30 7401      		movw r14,r8
 2489               	.L114:
 2490               	.LVL245:
 420:draw.c        **** 		{
 421:draw.c        **** 			ii = i;
 422:draw.c        **** 		} else
 423:draw.c        **** 		{
 424:draw.c        **** 			ii = (7-i);
 425:draw.c        **** 		}	
 426:draw.c        **** 	
 427:draw.c        **** 	
 428:draw.c        **** 		for (x = 0; x < CUBE_SIZE; x++)
 429:draw.c        **** 		{
 430:draw.c        **** 			for (y = 0; y < CUBE_SIZE; y++)
 431:draw.c        **** 			{
 432:draw.c        **** 				if (direction == -1)
 433:draw.c        **** 				{
 434:draw.c        **** 					iii = ii+1;
 2491               		.loc 1 434 0
 2492 0a32 C701      		movw r24,r14
 2493 0a34 0196      		adiw r24,1
 435:draw.c        **** 				} else
 436:draw.c        **** 				{
 437:draw.c        **** 					iii = ii-1;
 2494               		.loc 1 437 0
 2495 0a36 9701      		movw r18,r14
 2496 0a38 2150      		subi r18,lo8(-(-1))
 2497 0a3a 3040      		sbci r19,hi8(-(-1))
 2498 0a3c 4FEF      		ldi r20,lo8(-1)
 2499 0a3e 6416      		cp r6,r20
 2500 0a40 4FEF      		ldi r20,hi8(-1)
 2501 0a42 7406      		cpc r7,r20
 2502 0a44 01F4      		brne .L115
 2503 0a46 B82E      		mov r11,r24
 2504 0a48 D92E      		mov r13,r25
 2505 0a4a 00C0      		rjmp .L116
 2506               	.L115:
 2507 0a4c B22E      		mov r11,r18
 2508 0a4e D32E      		mov r13,r19
 2509               	.L116:
 428:draw.c        **** 		for (x = 0; x < CUBE_SIZE; x++)
 2510               		.loc 1 428 0
 2511 0a50 00E0      		ldi r16,lo8(0)
 2512 0a52 10E0      		ldi r17,hi8(0)
 2513 0a54 00C0      		rjmp .L117
 2514               	.LVL246:
 2515               	.L121:
 438:draw.c        **** 				}
 439:draw.c        **** 				
 440:draw.c        **** 				if (axis == AXIS_Z)
 2516               		.loc 1 440 0
 2517 0a56 8AE7      		ldi r24,lo8(122)
 2518 0a58 C816      		cp r12,r24
 2519 0a5a 01F4      		brne .L118
 441:draw.c        **** 				{
 442:draw.c        **** 					state = getvoxel(x,y,iii);
 2520               		.loc 1 442 0
 2521 0a5c C801      		movw r24,r16
 2522 0a5e BE01      		movw r22,r28
 2523 0a60 4B2D      		mov r20,r11
 2524 0a62 5D2D      		mov r21,r13
 2525 0a64 0E94 0000 		call getvoxel
 2526 0a68 282F      		mov r18,r24
 2527               	.LVL247:
 443:draw.c        **** 					altervoxel(x,y,ii,state);
 2528               		.loc 1 443 0
 2529 0a6a C801      		movw r24,r16
 2530               	.LVL248:
 2531 0a6c BE01      		movw r22,r28
 2532 0a6e A701      		movw r20,r14
 2533 0a70 00C0      		rjmp .L136
 2534               	.LVL249:
 2535               	.L118:
 444:draw.c        **** 				}
 445:draw.c        **** 				
 446:draw.c        **** 				if (axis == AXIS_Y)
 2536               		.loc 1 446 0
 2537 0a72 49E7      		ldi r20,lo8(121)
 2538 0a74 C416      		cp r12,r20
 2539 0a76 01F4      		brne .L120
 447:draw.c        **** 				{
 448:draw.c        **** 					state = getvoxel(x,iii,y);
 2540               		.loc 1 448 0
 2541 0a78 C801      		movw r24,r16
 2542 0a7a 6B2D      		mov r22,r11
 2543 0a7c 7D2D      		mov r23,r13
 2544 0a7e AE01      		movw r20,r28
 2545 0a80 0E94 0000 		call getvoxel
 2546 0a84 282F      		mov r18,r24
 2547               	.LVL250:
 449:draw.c        **** 					altervoxel(x,ii,y,state);
 2548               		.loc 1 449 0
 2549 0a86 C801      		movw r24,r16
 2550               	.LVL251:
 2551 0a88 B701      		movw r22,r14
 2552 0a8a AE01      		movw r20,r28
 2553 0a8c 00C0      		rjmp .L136
 2554               	.LVL252:
 2555               	.L120:
 450:draw.c        **** 				}
 451:draw.c        **** 				
 452:draw.c        **** 				if (axis == AXIS_X)
 2556               		.loc 1 452 0
 2557 0a8e 88E7      		ldi r24,lo8(120)
 2558 0a90 C816      		cp r12,r24
 2559 0a92 01F4      		brne .L119
 453:draw.c        **** 				{
 454:draw.c        **** 					state = getvoxel(iii,y,x);
 2560               		.loc 1 454 0
 2561 0a94 8B2D      		mov r24,r11
 2562 0a96 9D2D      		mov r25,r13
 2563 0a98 BE01      		movw r22,r28
 2564 0a9a A801      		movw r20,r16
 2565 0a9c 0E94 0000 		call getvoxel
 2566 0aa0 282F      		mov r18,r24
 2567               	.LVL253:
 455:draw.c        **** 					altervoxel(ii,y,x,state);
 2568               		.loc 1 455 0
 2569 0aa2 C701      		movw r24,r14
 2570               	.LVL254:
 2571 0aa4 BE01      		movw r22,r28
 2572 0aa6 A801      		movw r20,r16
 2573               	.LVL255:
 2574               	.L136:
 2575 0aa8 30E0      		ldi r19,lo8(0)
 2576 0aaa 0E94 0000 		call altervoxel
 2577               	.L119:
 430:draw.c        **** 			for (y = 0; y < CUBE_SIZE; y++)
 2578               		.loc 1 430 0
 2579 0aae 2196      		adiw r28,1
 2580               	.LVL256:
 2581 0ab0 C830      		cpi r28,8
 2582 0ab2 D105      		cpc r29,__zero_reg__
 2583 0ab4 01F4      		brne .L121
 428:draw.c        **** 		for (x = 0; x < CUBE_SIZE; x++)
 2584               		.loc 1 428 0
 2585 0ab6 0F5F      		subi r16,lo8(-(1))
 2586 0ab8 1F4F      		sbci r17,hi8(-(1))
 2587               	.LVL257:
 2588 0aba 0830      		cpi r16,8
 2589 0abc 1105      		cpc r17,__zero_reg__
 2590 0abe 01F0      		breq .L122
 2591               	.LVL258:
 2592               	.L117:
 419:draw.c        **** 		if (direction == -1)
 2593               		.loc 1 419 0 discriminator 1
 2594 0ac0 C0E0      		ldi r28,lo8(0)
 2595 0ac2 D0E0      		ldi r29,hi8(0)
 2596 0ac4 00C0      		rjmp .L121
 2597               	.LVL259:
 2598               	.L122:
 417:draw.c        **** 	for (i = 0; i < CUBE_SIZE; i++)
 2599               		.loc 1 417 0
 2600 0ac6 0894      		sec
 2601 0ac8 811C      		adc r8,__zero_reg__
 2602 0aca 911C      		adc r9,__zero_reg__
 2603               	.LVL260:
 2604 0acc 48E0      		ldi r20,lo8(8)
 2605 0ace 8416      		cp r8,r20
 2606 0ad0 9104      		cpc r9,__zero_reg__
 2607 0ad2 01F0      		breq .+2
 2608 0ad4 00C0      		rjmp .L123
 456:draw.c        **** 				}
 457:draw.c        **** 			}
 458:draw.c        **** 		}
 459:draw.c        **** 	}
 460:draw.c        **** 	
 461:draw.c        **** 	if (direction == -1)
 2609               		.loc 1 461 0
 2610 0ad6 8FEF      		ldi r24,lo8(-1)
 2611 0ad8 6816      		cp r6,r24
 2612 0ada 8FEF      		ldi r24,hi8(-1)
 2613 0adc 7806      		cpc r7,r24
 2614 0ade 01F4      		brne .L132
 462:draw.c        **** 	{
 463:draw.c        **** 		i = 7;
 2615               		.loc 1 463 0
 2616 0ae0 A7E0      		ldi r26,lo8(7)
 2617 0ae2 EA2E      		mov r14,r26
 2618 0ae4 F12C      		mov r15,__zero_reg__
 2619               	.LVL261:
 2620 0ae6 00C0      		rjmp .L124
 2621               	.LVL262:
 2622               	.L132:
 464:draw.c        **** 	} else
 465:draw.c        **** 	{
 466:draw.c        **** 		i = 0;
 2623               		.loc 1 466 0
 2624 0ae8 EE24      		clr r14
 2625 0aea FF24      		clr r15
 2626               	.LVL263:
 2627               	.L124:
 467:draw.c        **** 	}	
 468:draw.c        **** 	
 469:draw.c        **** 	for (x = 0; x < CUBE_SIZE; x++)
 2628               		.loc 1 469 0
 2629 0aec 00E0      		ldi r16,lo8(0)
 2630 0aee 10E0      		ldi r17,hi8(0)
 2631 0af0 00C0      		rjmp .L125
 2632               	.LVL264:
 2633               	.L129:
 470:draw.c        **** 	{
 471:draw.c        **** 		for (y = 0; y < CUBE_SIZE; y++)
 472:draw.c        **** 		{
 473:draw.c        **** 			if (axis == AXIS_Z)
 2634               		.loc 1 473 0
 2635 0af2 4AE7      		ldi r20,lo8(122)
 2636 0af4 C416      		cp r12,r20
 2637 0af6 01F4      		brne .L126
 474:draw.c        **** 				clrvoxel(x,y,i);
 2638               		.loc 1 474 0
 2639 0af8 C801      		movw r24,r16
 2640 0afa BE01      		movw r22,r28
 2641 0afc A701      		movw r20,r14
 2642 0afe 00C0      		rjmp .L137
 2643               	.L126:
 475:draw.c        **** 				
 476:draw.c        **** 			if (axis == AXIS_Y)
 2644               		.loc 1 476 0
 2645 0b00 89E7      		ldi r24,lo8(121)
 2646 0b02 C816      		cp r12,r24
 2647 0b04 01F4      		brne .L128
 477:draw.c        **** 				clrvoxel(x,i,y);
 2648               		.loc 1 477 0
 2649 0b06 C801      		movw r24,r16
 2650 0b08 B701      		movw r22,r14
 2651 0b0a AE01      		movw r20,r28
 2652 0b0c 00C0      		rjmp .L137
 2653               	.L128:
 478:draw.c        **** 			
 479:draw.c        **** 			if (axis == AXIS_X)
 2654               		.loc 1 479 0
 2655 0b0e 48E7      		ldi r20,lo8(120)
 2656 0b10 C416      		cp r12,r20
 2657 0b12 01F4      		brne .L127
 480:draw.c        **** 				clrvoxel(i,y,x);
 2658               		.loc 1 480 0
 2659 0b14 C701      		movw r24,r14
 2660 0b16 BE01      		movw r22,r28
 2661 0b18 A801      		movw r20,r16
 2662               	.L137:
 2663 0b1a 0E94 0000 		call clrvoxel
 2664               	.L127:
 471:draw.c        **** 		for (y = 0; y < CUBE_SIZE; y++)
 2665               		.loc 1 471 0
 2666 0b1e 2196      		adiw r28,1
 2667               	.LVL265:
 2668 0b20 C830      		cpi r28,8
 2669 0b22 D105      		cpc r29,__zero_reg__
 2670 0b24 01F4      		brne .L129
 469:draw.c        **** 	for (x = 0; x < CUBE_SIZE; x++)
 2671               		.loc 1 469 0
 2672 0b26 0F5F      		subi r16,lo8(-(1))
 2673 0b28 1F4F      		sbci r17,hi8(-(1))
 2674               	.LVL266:
 2675 0b2a 0830      		cpi r16,8
 2676 0b2c 1105      		cpc r17,__zero_reg__
 2677 0b2e 01F0      		breq .L113
 2678               	.LVL267:
 2679               	.L125:
 466:draw.c        **** 		i = 0;
 2680               		.loc 1 466 0 discriminator 1
 2681 0b30 C0E0      		ldi r28,lo8(0)
 2682 0b32 D0E0      		ldi r29,hi8(0)
 2683 0b34 00C0      		rjmp .L129
 2684               	.LVL268:
 2685               	.L113:
 2686               	/* epilogue start */
 481:draw.c        **** 		}
 482:draw.c        **** 	}
 483:draw.c        **** }
 2687               		.loc 1 483 0
 2688 0b36 DF91      		pop r29
 2689 0b38 CF91      		pop r28
 2690               	.LVL269:
 2691 0b3a 1F91      		pop r17
 2692 0b3c 0F91      		pop r16
 2693               	.LVL270:
 2694 0b3e FF90      		pop r15
 2695 0b40 EF90      		pop r14
 2696               	.LVL271:
 2697 0b42 DF90      		pop r13
 2698               	.LVL272:
 2699 0b44 CF90      		pop r12
 2700               	.LVL273:
 2701 0b46 BF90      		pop r11
 2702 0b48 9F90      		pop r9
 2703 0b4a 8F90      		pop r8
 2704 0b4c 7F90      		pop r7
 2705 0b4e 6F90      		pop r6
 2706               	.LVL274:
 2707 0b50 5F90      		pop r5
 2708 0b52 4F90      		pop r4
 2709 0b54 0895      		ret
 2710               		.cfi_endproc
 2711               	.LFE27:
 2713               	.global	mirror_y
 2715               	mirror_y:
 2716               	.LFB28:
 484:draw.c        **** 
 485:draw.c        **** // Flip the cube 180 degrees along the y axis.
 486:draw.c        **** void mirror_y (void)
 487:draw.c        **** {
 2717               		.loc 1 487 0
 2718               		.cfi_startproc
 2719 0b56 4F92      		push r4
 2720               	.LCFI118:
 2721               		.cfi_def_cfa_offset 3
 2722               		.cfi_offset 4, -2
 2723 0b58 5F92      		push r5
 2724               	.LCFI119:
 2725               		.cfi_def_cfa_offset 4
 2726               		.cfi_offset 5, -3
 2727 0b5a 6F92      		push r6
 2728               	.LCFI120:
 2729               		.cfi_def_cfa_offset 5
 2730               		.cfi_offset 6, -4
 2731 0b5c 7F92      		push r7
 2732               	.LCFI121:
 2733               		.cfi_def_cfa_offset 6
 2734               		.cfi_offset 7, -5
 2735 0b5e 8F92      		push r8
 2736               	.LCFI122:
 2737               		.cfi_def_cfa_offset 7
 2738               		.cfi_offset 8, -6
 2739 0b60 9F92      		push r9
 2740               	.LCFI123:
 2741               		.cfi_def_cfa_offset 8
 2742               		.cfi_offset 9, -7
 2743 0b62 AF92      		push r10
 2744               	.LCFI124:
 2745               		.cfi_def_cfa_offset 9
 2746               		.cfi_offset 10, -8
 2747 0b64 BF92      		push r11
 2748               	.LCFI125:
 2749               		.cfi_def_cfa_offset 10
 2750               		.cfi_offset 11, -9
 2751 0b66 CF92      		push r12
 2752               	.LCFI126:
 2753               		.cfi_def_cfa_offset 11
 2754               		.cfi_offset 12, -10
 2755 0b68 DF92      		push r13
 2756               	.LCFI127:
 2757               		.cfi_def_cfa_offset 12
 2758               		.cfi_offset 13, -11
 2759 0b6a EF92      		push r14
 2760               	.LCFI128:
 2761               		.cfi_def_cfa_offset 13
 2762               		.cfi_offset 14, -12
 2763 0b6c FF92      		push r15
 2764               	.LCFI129:
 2765               		.cfi_def_cfa_offset 14
 2766               		.cfi_offset 15, -13
 2767 0b6e 0F93      		push r16
 2768               	.LCFI130:
 2769               		.cfi_def_cfa_offset 15
 2770               		.cfi_offset 16, -14
 2771 0b70 1F93      		push r17
 2772               	.LCFI131:
 2773               		.cfi_def_cfa_offset 16
 2774               		.cfi_offset 17, -15
 2775 0b72 CF93      		push r28
 2776               	.LCFI132:
 2777               		.cfi_def_cfa_offset 17
 2778               		.cfi_offset 28, -16
 2779 0b74 DF93      		push r29
 2780               	.LCFI133:
 2781               		.cfi_def_cfa_offset 18
 2782               		.cfi_offset 29, -17
 2783 0b76 CDB7      		in r28,__SP_L__
 2784 0b78 DEB7      		in r29,__SP_H__
 2785 0b7a C054      		subi r28,lo8(-(-64))
 2786 0b7c D040      		sbci r29,hi8(-(-64))
 2787               	.LCFI134:
 2788               		.cfi_def_cfa 28, 82
 2789 0b7e 0FB6      		in __tmp_reg__,__SREG__
 2790 0b80 F894      		cli
 2791 0b82 DEBF      		out __SP_H__,r29
 2792 0b84 0FBE      		out __SREG__,__tmp_reg__
 2793 0b86 CDBF      		out __SP_L__,r28
 2794               	/* prologue: function */
 2795               	/* frame size = 64 */
 2796               	/* stack size = 80 */
 2797               	.L__stack_usage = 80
 488:draw.c        ****     unsigned char buffer[CUBE_SIZE][CUBE_SIZE];
 489:draw.c        ****     unsigned char x,y,z;
 490:draw.c        **** 
 491:draw.c        ****     memcpy(buffer, cube, CUBE_BYTES); // copy the current cube into a buffer.
 2798               		.loc 1 491 0
 2799 0b88 DE01      		movw r26,r28
 2800 0b8a 1196      		adiw r26,1
 2801 0b8c E0E0      		ldi r30,lo8(cube)
 2802 0b8e F0E0      		ldi r31,hi8(cube)
 2803 0b90 80E4      		ldi r24,lo8(64)
 2804               	.L139:
 2805 0b92 0190      		ld r0,Z+
 2806 0b94 0D92      		st X+,r0
 2807 0b96 8150      		subi r24,lo8(-(-1))
 2808 0b98 01F4      		brne .L139
 492:draw.c        **** 
 493:draw.c        ****     fill(0x00);
 2809               		.loc 1 493 0
 2810 0b9a 0E94 0000 		call fill
 2811               	.LVL275:
 2812 0b9e 5E01      		movw r10,r28
 2813 0ba0 0894      		sec
 2814 0ba2 A11C      		adc r10,__zero_reg__
 2815 0ba4 B11C      		adc r11,__zero_reg__
 2816 0ba6 CC24      		clr r12
 2817 0ba8 DD24      		clr r13
 486:draw.c        **** void mirror_y (void)
 2818               		.loc 1 486 0
 2819 0baa 17E0      		ldi r17,lo8(7)
 2820 0bac 612E      		mov r6,r17
 2821 0bae 712C      		mov r7,__zero_reg__
 2822 0bb0 00C0      		rjmp .L140
 2823               	.LVL276:
 2824               	.L142:
 494:draw.c        ****     for (z=0; z<CUBE_SIZE; z++)
 495:draw.c        ****     {
 496:draw.c        ****         for (y=0; y<CUBE_SIZE; y++)
 497:draw.c        ****         {
 498:draw.c        ****             for (x=0; x<CUBE_SIZE; x++)
 499:draw.c        ****             {
 500:draw.c        ****                 if (buffer[z][y] & (0x01 << x))
 2825               		.loc 1 500 0
 2826 0bb2 F201      		movw r30,r4
 2827 0bb4 8081      		ld r24,Z
 2828 0bb6 90E0      		ldi r25,lo8(0)
 2829 0bb8 0E2C      		mov r0,r14
 2830 0bba 00C0      		rjmp 2f
 2831 0bbc 9595      	1:	asr r25
 2832 0bbe 8795      		ror r24
 2833 0bc0 0A94      	2:	dec r0
 2834 0bc2 02F4      		brpl 1b
 2835 0bc4 80FF      		sbrs r24,0
 2836 0bc6 00C0      		rjmp .L141
 501:draw.c        ****                     setvoxel(x,CUBE_SIZE-1-y,z);
 2837               		.loc 1 501 0
 2838 0bc8 C701      		movw r24,r14
 2839 0bca B401      		movw r22,r8
 2840 0bcc A601      		movw r20,r12
 2841 0bce 0E94 0000 		call setvoxel
 2842               	.L141:
 2843 0bd2 0894      		sec
 2844 0bd4 E11C      		adc r14,__zero_reg__
 2845 0bd6 F11C      		adc r15,__zero_reg__
 498:draw.c        ****             for (x=0; x<CUBE_SIZE; x++)
 2846               		.loc 1 498 0
 2847 0bd8 F8E0      		ldi r31,lo8(8)
 2848 0bda EF16      		cp r14,r31
 2849 0bdc F104      		cpc r15,__zero_reg__
 2850 0bde 01F4      		brne .L142
 2851 0be0 0F5F      		subi r16,lo8(-(1))
 2852 0be2 1F4F      		sbci r17,hi8(-(1))
 496:draw.c        ****         for (y=0; y<CUBE_SIZE; y++)
 2853               		.loc 1 496 0
 2854 0be4 0830      		cpi r16,8
 2855 0be6 1105      		cpc r17,__zero_reg__
 2856 0be8 01F0      		breq .L143
 2857               	.LVL277:
 2858               	.L145:
 487:draw.c        **** {
 2859               		.loc 1 487 0 discriminator 1
 2860 0bea EE24      		clr r14
 2861 0bec FF24      		clr r15
 486:draw.c        **** void mirror_y (void)
 2862               		.loc 1 486 0 discriminator 1
 2863 0bee 2501      		movw r4,r10
 2864 0bf0 400E      		add r4,r16
 2865 0bf2 511E      		adc r5,r17
 2866 0bf4 4301      		movw r8,r6
 2867 0bf6 801A      		sub r8,r16
 2868 0bf8 910A      		sbc r9,r17
 2869 0bfa 00C0      		rjmp .L142
 2870               	.LVL278:
 2871               	.L143:
 496:draw.c        ****         for (y=0; y<CUBE_SIZE; y++)
 2872               		.loc 1 496 0
 2873 0bfc 0894      		sec
 2874 0bfe C11C      		adc r12,__zero_reg__
 2875 0c00 D11C      		adc r13,__zero_reg__
 2876 0c02 88E0      		ldi r24,lo8(8)
 2877 0c04 90E0      		ldi r25,hi8(8)
 2878 0c06 A80E      		add r10,r24
 2879 0c08 B91E      		adc r11,r25
 494:draw.c        ****     for (z=0; z<CUBE_SIZE; z++)
 2880               		.loc 1 494 0
 2881 0c0a 98E0      		ldi r25,lo8(8)
 2882 0c0c C916      		cp r12,r25
 2883 0c0e D104      		cpc r13,__zero_reg__
 2884 0c10 01F0      		breq .L138
 2885               	.L140:
 2886               	.LVL279:
 487:draw.c        **** {
 2887               		.loc 1 487 0 discriminator 1
 2888 0c12 00E0      		ldi r16,lo8(0)
 2889 0c14 10E0      		ldi r17,hi8(0)
 2890 0c16 00C0      		rjmp .L145
 2891               	.LVL280:
 2892               	.L138:
 2893               	/* epilogue start */
 502:draw.c        ****             }
 503:draw.c        ****         }
 504:draw.c        ****     }
 505:draw.c        **** 
 506:draw.c        **** }
 2894               		.loc 1 506 0
 2895 0c18 C05C      		subi r28,lo8(-(64))
 2896 0c1a DF4F      		sbci r29,hi8(-(64))
 2897 0c1c 0FB6      		in __tmp_reg__,__SREG__
 2898 0c1e F894      		cli
 2899 0c20 DEBF      		out __SP_H__,r29
 2900 0c22 0FBE      		out __SREG__,__tmp_reg__
 2901 0c24 CDBF      		out __SP_L__,r28
 2902 0c26 DF91      		pop r29
 2903 0c28 CF91      		pop r28
 2904 0c2a 1F91      		pop r17
 2905 0c2c 0F91      		pop r16
 2906 0c2e FF90      		pop r15
 2907 0c30 EF90      		pop r14
 2908 0c32 DF90      		pop r13
 2909 0c34 CF90      		pop r12
 2910 0c36 BF90      		pop r11
 2911 0c38 AF90      		pop r10
 2912 0c3a 9F90      		pop r9
 2913 0c3c 8F90      		pop r8
 2914 0c3e 7F90      		pop r7
 2915 0c40 6F90      		pop r6
 2916 0c42 5F90      		pop r5
 2917 0c44 4F90      		pop r4
 2918 0c46 0895      		ret
 2919               		.cfi_endproc
 2920               	.LFE28:
 2922               	.global	mirror_x
 2924               	mirror_x:
 2925               	.LFB29:
 507:draw.c        **** 
 508:draw.c        **** // Flip the cube 180 degrees along the x axis
 509:draw.c        **** void mirror_x (void)
 510:draw.c        **** {
 2926               		.loc 1 510 0
 2927               		.cfi_startproc
 2928 0c48 AF92      		push r10
 2929               	.LCFI135:
 2930               		.cfi_def_cfa_offset 3
 2931               		.cfi_offset 10, -2
 2932 0c4a BF92      		push r11
 2933               	.LCFI136:
 2934               		.cfi_def_cfa_offset 4
 2935               		.cfi_offset 11, -3
 2936 0c4c CF92      		push r12
 2937               	.LCFI137:
 2938               		.cfi_def_cfa_offset 5
 2939               		.cfi_offset 12, -4
 2940 0c4e DF92      		push r13
 2941               	.LCFI138:
 2942               		.cfi_def_cfa_offset 6
 2943               		.cfi_offset 13, -5
 2944 0c50 EF92      		push r14
 2945               	.LCFI139:
 2946               		.cfi_def_cfa_offset 7
 2947               		.cfi_offset 14, -6
 2948 0c52 FF92      		push r15
 2949               	.LCFI140:
 2950               		.cfi_def_cfa_offset 8
 2951               		.cfi_offset 15, -7
 2952 0c54 0F93      		push r16
 2953               	.LCFI141:
 2954               		.cfi_def_cfa_offset 9
 2955               		.cfi_offset 16, -8
 2956 0c56 1F93      		push r17
 2957               	.LCFI142:
 2958               		.cfi_def_cfa_offset 10
 2959               		.cfi_offset 17, -9
 2960 0c58 CF93      		push r28
 2961               	.LCFI143:
 2962               		.cfi_def_cfa_offset 11
 2963               		.cfi_offset 28, -10
 2964 0c5a DF93      		push r29
 2965               	.LCFI144:
 2966               		.cfi_def_cfa_offset 12
 2967               		.cfi_offset 29, -11
 2968 0c5c CDB7      		in r28,__SP_L__
 2969 0c5e DEB7      		in r29,__SP_H__
 2970 0c60 C054      		subi r28,lo8(-(-64))
 2971 0c62 D040      		sbci r29,hi8(-(-64))
 2972               	.LCFI145:
 2973               		.cfi_def_cfa 28, 76
 2974 0c64 0FB6      		in __tmp_reg__,__SREG__
 2975 0c66 F894      		cli
 2976 0c68 DEBF      		out __SP_H__,r29
 2977 0c6a 0FBE      		out __SREG__,__tmp_reg__
 2978 0c6c CDBF      		out __SP_L__,r28
 2979               	/* prologue: function */
 2980               	/* frame size = 64 */
 2981               	/* stack size = 74 */
 2982               	.L__stack_usage = 74
 511:draw.c        ****     unsigned char buffer[CUBE_SIZE][CUBE_SIZE];
 512:draw.c        ****     unsigned char y,z;
 513:draw.c        **** 
 514:draw.c        ****     memcpy(buffer, cube, CUBE_BYTES); // copy the current cube into a buffer.
 2983               		.loc 1 514 0
 2984 0c6e DE01      		movw r26,r28
 2985 0c70 1196      		adiw r26,1
 2986 0c72 E0E0      		ldi r30,lo8(cube)
 2987 0c74 F0E0      		ldi r31,hi8(cube)
 2988 0c76 80E4      		ldi r24,lo8(64)
 2989               	.L149:
 2990 0c78 0190      		ld r0,Z+
 2991 0c7a 0D92      		st X+,r0
 2992 0c7c 8150      		subi r24,lo8(-(-1))
 2993 0c7e 01F4      		brne .L149
 515:draw.c        **** 
 516:draw.c        ****     fill(0x00);
 2994               		.loc 1 516 0
 2995 0c80 0E94 0000 		call fill
 2996               	.LVL281:
 2997 0c84 6E01      		movw r12,r28
 2998 0c86 0894      		sec
 2999 0c88 C11C      		adc r12,__zero_reg__
 3000 0c8a D11C      		adc r13,__zero_reg__
 3001 0c8c EE24      		clr r14
 3002 0c8e FF24      		clr r15
 3003 0c90 00C0      		rjmp .L150
 3004               	.LVL282:
 3005               	.L151:
 509:draw.c        **** void mirror_x (void)
 3006               		.loc 1 509 0 discriminator 2
 3007 0c92 F601      		movw r30,r12
 3008 0c94 E00F      		add r30,r16
 3009 0c96 F11F      		adc r31,r17
 517:draw.c        ****     
 518:draw.c        ****     for (z=0; z<CUBE_SIZE; z++)
 519:draw.c        ****     {
 520:draw.c        ****         for (y=0; y<CUBE_SIZE; y++)
 521:draw.c        ****         {
 522:draw.c        ****             // This will break with different buffer sizes..
 523:draw.c        ****             cube[z][y] = flipbyte(buffer[z][y]);
 3010               		.loc 1 523 0 discriminator 2
 3011 0c98 8081      		ld r24,Z
 3012 0c9a 0E94 0000 		call flipbyte
 3013 0c9e F501      		movw r30,r10
 3014 0ca0 E00F      		add r30,r16
 3015 0ca2 F11F      		adc r31,r17
 3016 0ca4 E050      		subi r30,lo8(-(cube))
 3017 0ca6 F040      		sbci r31,hi8(-(cube))
 3018 0ca8 8083      		st Z,r24
 3019 0caa 0F5F      		subi r16,lo8(-(1))
 3020 0cac 1F4F      		sbci r17,hi8(-(1))
 520:draw.c        ****         for (y=0; y<CUBE_SIZE; y++)
 3021               		.loc 1 520 0 discriminator 2
 3022 0cae 0830      		cpi r16,8
 3023 0cb0 1105      		cpc r17,__zero_reg__
 3024 0cb2 01F4      		brne .L151
 520:draw.c        ****         for (y=0; y<CUBE_SIZE; y++)
 3025               		.loc 1 520 0 is_stmt 0
 3026 0cb4 0894      		sec
 3027 0cb6 E11C      		adc r14,__zero_reg__
 3028 0cb8 F11C      		adc r15,__zero_reg__
 3029 0cba 88E0      		ldi r24,lo8(8)
 3030 0cbc 90E0      		ldi r25,hi8(8)
 3031 0cbe C80E      		add r12,r24
 3032 0cc0 D91E      		adc r13,r25
 518:draw.c        ****     for (z=0; z<CUBE_SIZE; z++)
 3033               		.loc 1 518 0 is_stmt 1
 3034 0cc2 98E0      		ldi r25,lo8(8)
 3035 0cc4 E916      		cp r14,r25
 3036 0cc6 F104      		cpc r15,__zero_reg__
 3037 0cc8 01F0      		breq .L148
 3038               	.LVL283:
 3039               	.L150:
 510:draw.c        **** {
 3040               		.loc 1 510 0 discriminator 1
 3041 0cca 00E0      		ldi r16,lo8(0)
 3042 0ccc 10E0      		ldi r17,hi8(0)
 3043               		.loc 1 523 0 discriminator 1
 3044 0cce 5701      		movw r10,r14
 3045 0cd0 83E0      		ldi r24,3
 3046 0cd2 AA0C      	1:	lsl r10
 3047 0cd4 BB1C      		rol r11
 3048 0cd6 8A95      		dec r24
 3049 0cd8 01F4      		brne 1b
 3050 0cda 00C0      		rjmp .L151
 3051               	.LVL284:
 3052               	.L148:
 3053               	/* epilogue start */
 524:draw.c        ****         }
 525:draw.c        ****     }
 526:draw.c        **** }
 3054               		.loc 1 526 0
 3055 0cdc C05C      		subi r28,lo8(-(64))
 3056 0cde DF4F      		sbci r29,hi8(-(64))
 3057 0ce0 0FB6      		in __tmp_reg__,__SREG__
 3058 0ce2 F894      		cli
 3059 0ce4 DEBF      		out __SP_H__,r29
 3060 0ce6 0FBE      		out __SREG__,__tmp_reg__
 3061 0ce8 CDBF      		out __SP_L__,r28
 3062 0cea DF91      		pop r29
 3063 0cec CF91      		pop r28
 3064 0cee 1F91      		pop r17
 3065 0cf0 0F91      		pop r16
 3066 0cf2 FF90      		pop r15
 3067 0cf4 EF90      		pop r14
 3068 0cf6 DF90      		pop r13
 3069 0cf8 CF90      		pop r12
 3070 0cfa BF90      		pop r11
 3071 0cfc AF90      		pop r10
 3072 0cfe 0895      		ret
 3073               		.cfi_endproc
 3074               	.LFE29:
 3076               	.global	mirror_z
 3078               	mirror_z:
 3079               	.LFB30:
 527:draw.c        **** 
 528:draw.c        **** // flip the cube 180 degrees along the z axis
 529:draw.c        **** void mirror_z (void)
 530:draw.c        **** {
 3080               		.loc 1 530 0
 3081               		.cfi_startproc
 3082 0d00 CF93      		push r28
 3083               	.LCFI146:
 3084               		.cfi_def_cfa_offset 3
 3085               		.cfi_offset 28, -2
 3086 0d02 DF93      		push r29
 3087               	.LCFI147:
 3088               		.cfi_def_cfa_offset 4
 3089               		.cfi_offset 29, -3
 3090 0d04 CDB7      		in r28,__SP_L__
 3091 0d06 DEB7      		in r29,__SP_H__
 3092 0d08 C054      		subi r28,lo8(-(-64))
 3093 0d0a D040      		sbci r29,hi8(-(-64))
 3094               	.LCFI148:
 3095               		.cfi_def_cfa 28, 68
 3096 0d0c 0FB6      		in __tmp_reg__,__SREG__
 3097 0d0e F894      		cli
 3098 0d10 DEBF      		out __SP_H__,r29
 3099 0d12 0FBE      		out __SREG__,__tmp_reg__
 3100 0d14 CDBF      		out __SP_L__,r28
 3101               	/* prologue: function */
 3102               	/* frame size = 64 */
 3103               	/* stack size = 66 */
 3104               	.L__stack_usage = 66
 531:draw.c        ****     unsigned char buffer[CUBE_SIZE][CUBE_SIZE];
 532:draw.c        ****     unsigned char z, y;
 533:draw.c        **** 
 534:draw.c        ****     memcpy(buffer, cube, CUBE_BYTES); // copy the current cube into a buffer.
 3105               		.loc 1 534 0
 3106 0d16 DE01      		movw r26,r28
 3107 0d18 1196      		adiw r26,1
 3108 0d1a E0E0      		ldi r30,lo8(cube)
 3109 0d1c F0E0      		ldi r31,hi8(cube)
 3110 0d1e 80E4      		ldi r24,lo8(64)
 3111               	.L156:
 3112 0d20 0190      		ld r0,Z+
 3113 0d22 0D92      		st X+,r0
 3114 0d24 8150      		subi r24,lo8(-(-1))
 3115 0d26 01F4      		brne .L156
 3116               	.LVL285:
 3117 0d28 80E0      		ldi r24,lo8(0)
 3118 0d2a 90E0      		ldi r25,hi8(0)
 3119 0d2c 00C0      		rjmp .L157
 3120               	.LVL286:
 3121               	.L158:
 529:draw.c        **** void mirror_z (void)
 3122               		.loc 1 529 0 discriminator 2
 3123 0d2e FB01      		movw r30,r22
 3124 0d30 E20F      		add r30,r18
 3125 0d32 F31F      		adc r31,r19
 535:draw.c        **** 
 536:draw.c        ****     for (y=0; y<CUBE_SIZE; y++)
 537:draw.c        ****     {
 538:draw.c        ****         for (z=0; z<CUBE_SIZE; z++)
 539:draw.c        ****         {
 540:draw.c        ****             cube[CUBE_SIZE-1-z][y] = buffer[z][y];
 3126               		.loc 1 540 0 discriminator 2
 3127 0d34 A081      		ld r26,Z
 3128 0d36 FA01      		movw r30,r20
 3129 0d38 B3E0      		ldi r27,3
 3130 0d3a EE0F      	1:	lsl r30
 3131 0d3c FF1F      		rol r31
 3132 0d3e BA95      		dec r27
 3133 0d40 01F4      		brne 1b
 3134 0d42 E80F      		add r30,r24
 3135 0d44 F91F      		adc r31,r25
 3136 0d46 E050      		subi r30,lo8(-(cube))
 3137 0d48 F040      		sbci r31,hi8(-(cube))
 3138 0d4a A083      		st Z,r26
 3139 0d4c 285F      		subi r18,lo8(-(8))
 3140 0d4e 3F4F      		sbci r19,hi8(-(8))
 3141 0d50 4150      		subi r20,lo8(-(-1))
 3142 0d52 5040      		sbci r21,hi8(-(-1))
 538:draw.c        ****         for (z=0; z<CUBE_SIZE; z++)
 3143               		.loc 1 538 0 discriminator 2
 3144 0d54 2034      		cpi r18,64
 3145 0d56 3105      		cpc r19,__zero_reg__
 3146 0d58 01F4      		brne .L158
 538:draw.c        ****         for (z=0; z<CUBE_SIZE; z++)
 3147               		.loc 1 538 0 is_stmt 0
 3148 0d5a 0196      		adiw r24,1
 536:draw.c        ****     for (y=0; y<CUBE_SIZE; y++)
 3149               		.loc 1 536 0 is_stmt 1
 3150 0d5c 8830      		cpi r24,8
 3151 0d5e 9105      		cpc r25,__zero_reg__
 3152 0d60 01F0      		breq .L155
 3153               	.LVL287:
 3154               	.L157:
 530:draw.c        **** {
 3155               		.loc 1 530 0 discriminator 1
 3156 0d62 47E0      		ldi r20,lo8(7)
 3157 0d64 50E0      		ldi r21,hi8(7)
 3158 0d66 20E0      		ldi r18,lo8(0)
 3159 0d68 30E0      		ldi r19,hi8(0)
 529:draw.c        **** void mirror_z (void)
 3160               		.loc 1 529 0 discriminator 1
 3161 0d6a 61E0      		ldi r22,lo8(1)
 3162 0d6c 70E0      		ldi r23,hi8(1)
 3163 0d6e 6C0F      		add r22,r28
 3164 0d70 7D1F      		adc r23,r29
 3165 0d72 680F      		add r22,r24
 3166 0d74 791F      		adc r23,r25
 3167 0d76 00C0      		rjmp .L158
 3168               	.LVL288:
 3169               	.L155:
 3170               	/* epilogue start */
 541:draw.c        ****         }
 542:draw.c        ****     }
 543:draw.c        **** }
 3171               		.loc 1 543 0
 3172 0d78 C05C      		subi r28,lo8(-(64))
 3173 0d7a DF4F      		sbci r29,hi8(-(64))
 3174 0d7c 0FB6      		in __tmp_reg__,__SREG__
 3175 0d7e F894      		cli
 3176 0d80 DEBF      		out __SP_H__,r29
 3177 0d82 0FBE      		out __SREG__,__tmp_reg__
 3178 0d84 CDBF      		out __SP_L__,r28
 3179 0d86 DF91      		pop r29
 3180 0d88 CF91      		pop r28
 3181 0d8a 0895      		ret
 3182               		.cfi_endproc
 3183               	.LFE30:
 3185               		.comm fb,64,1
 3186               		.comm cube,64,1
 3187               	.Letext0:
 3188               		.file 2 "cube.h"
DEFINED SYMBOLS
                            *ABS*:00000000 draw.c
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:2      *ABS*:0000003f __SREG__
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:3      *ABS*:0000003e __SP_H__
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:4      *ABS*:0000003d __SP_L__
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:5      *ABS*:00000034 __CCP__
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:6      *ABS*:00000000 __tmp_reg__
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:7      *ABS*:00000001 __zero_reg__
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:15     .text:00000000 inrange
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:59     .text:00000024 tmpclrvoxel
                            *COM*:00000040 fb
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:133    .text:00000070 clrvoxel
                            *COM*:00000040 cube
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:207    .text:000000bc tmpsetvoxel
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:280    .text:00000106 setvoxel
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:353    .text:00000150 getvoxel
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:431    .text:0000019a altervoxel
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:459    .text:000001ac flpvoxel
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:532    .text:000001f6 argorder
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:570    .text:00000214 setplane_z
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:617    .text:0000023e clrplane_z
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:662    .text:00000266 setplane_x
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:733    .text:000002ba clrplane_x
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:805    .text:00000310 setplane_y
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:847    .text:00000330 clrplane_y
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:887    .text:0000034e setplane
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:936    .text:00000376 clrplane
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:985    .text:0000039e fill
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:1039   .text:000003ce tmpfill
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:1093   .text:000003fe byteline
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:1133   .text:00000426 box_wireframe
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:1395   .text:00000552 box_walls
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:1671   .text:00000676 box_filled
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:1908   .text:0000075c flipbyte
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:1984   .text:000007be line
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:2365   .text:000009de tmp2cube
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:2392   .text:000009f2 shift
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:2715   .text:00000b56 mirror_y
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:2924   .text:00000c48 mirror_x
/var/folders/_t/3n28601j4f36k4h8t71c5mvr0000gn/T//ccxYCpzM.s:3078   .text:00000d00 mirror_z

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__floatsisf
__divsf3
__mulsf3
__addsf3
__fixunssfsi
